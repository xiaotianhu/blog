<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Rainyluo's BLOG]]></title>
  <link href="blog.v2cb.com/atom.xml" rel="self"/>
  <link href="blog.v2cb.com/"/>
  <updated>2020-11-04T10:02:23+08:00</updated>
  <id>blog.v2cb.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP的 Generator(yield)有啥用]]></title>
    <link href="blog.v2cb.com/16043884086250.html"/>
    <updated>2020-11-03T15:26:48+08:00</updated>
    <id>blog.v2cb.com/16043884086250.html</id>
    <content type="html"><![CDATA[
<p>原文:<a href="https://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html">https://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html</a><br/>
另一篇很经典的<a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html</a> 鸟哥已经有翻译了,就不写了.</p>

<p>PHP的5.5.0版本引入了Generator这个概念.我觉得这是个非常有用的工具,但是看起来很多PHP开发者对Generator并不熟悉.所以我觉得应该花点时间来解释一下它是怎么工作的,以及怎么用这个工具来简化代码.</p>

<h3 id="toc_0">理论</h3>

<p>先说明一件事儿:Generators并没有给语言添加了什么新的神奇能力.用Generator能完成的事儿,都可以用itarator迭代器来完成.所以,记住这一点 先来个栗子.假设要逐行循环读取一个文件,传统的程序很容易写:</p>

<pre><code class="language-php">$f = fopen($file, &#39;r&#39;);
while ($line = fgets($f)) {
    doSomethingWithLine($line);
}
</code></pre>

<p>随便用一下这个就很好用了.但是如果我们想把调用抽象一下呢,从一个抽象的数据源读取多行数据 .今天可能是读取文件,明天可能是从数据库读取,或者也可能从服务调用读取,或者其他什么方法.</p>

<p>目前为止,我们有两种选择来实现这个抽象.我们可以在调用方法后返回一个数组,或者可以返回一个迭代器.如果每次调用方法都返回数组,可能有俩问题:首先我们可能不能把全部数据都塞到内存里(如果文件有30G怎么办);其次,我们甚至不能把返回数据考虑成数组(例如我们想返回一个无限的序列,让调用发来决定调用多少).</p>

<p>所以剩下的就只有迭代器了.对于这个例子,转换成迭代器还是很简单的.本质上来说,对这个例子PHP已经有个内置的迭代器直接可以用了:SPLFileObject.为了演示一下,我们来实现一个:</p>

<pre><code class="language-php">class FileIterator implements Iterator {
    protected $f;
    public function __construct($file) {
        $this-&gt;f = fopen($file, &#39;r&#39;);
        if (!$this-&gt;f) throw new Exception();
    }
    public function current() {
        return fgets($this-&gt;f);
    }
    public function key() {
        return ftell($this-&gt;f);
    }
    public function next() {
    }
    public function rewind() {
        fseek($this-&gt;f, 0);
    }
    public function valid() {
        return !feof($this-&gt;f);
    }
}
</code></pre>

<p>看起来很简单对吧.其实没这么简单.如果仔细看看就会发现,我们没有完全遵从迭代器的原则来实现.Next和Rewind方法应该是唯一用来改变数据的方法.每次调用 current()方法都应该返回相同的数据.但是这个实现并不是这样.我是故意写错的,来演示一下把普通的代码直接转换成迭代器并没有那么容易.实际上,想写的完全正确还是挺麻烦的,来看看正确的实现方法:</p>

<pre><code class="language-php">class FileIterator implements Iterator {
    protected $f;
    protected $data;
    protected $key;
    public function __construct($file) {
        $this-&gt;f = fopen($file, &#39;r&#39;);
        if (!$this-&gt;f) throw new Exception();
    }
    public function __destruct() {
        fclose($this-&gt;f);
    }
    public function current() {
        return $this-&gt;data;
    }
    public function key() {
        return $this-&gt;key;
    }
    public function next() {
        $this-&gt;data = fgets($this-&gt;f);
        $this-&gt;key++;
    }
    public function rewind() {
        fseek($this-&gt;f, 0);
        $this-&gt;data = fgets($this-&gt;f);
        $this-&gt;key = 0;
    }
    public function valid() {
        return false !== $this-&gt;data;
    }
}
</code></pre>

<p>WOw,为了一个简单的循环文件要写一大坨代码和很多保存状态的变量(而且还是在很多复杂的工作已经在文件操作函数内解决了的情况下).想象一下,如果有更多的状态需要操作,或者更复杂的算法需要实现.在方法调用之间保存状态还可行,但是在组合方法调用的时候就更难了.所以让我们了解一个解决这种问题的迭代器:</p>

<pre><code class="language-php">function getLines($file) {
    $f = fopen($file, &#39;r&#39;);
    if (!$f) throw new Exception();
    while ($line = fgets($f)) {
        yield $line;
    }
    fclose($f);
}
</code></pre>

<p>简单多了对不对.实际上,跟之前面向过程的版本基本上一样,只是多了一个新的 yield 关键词.</p>

<h3 id="toc_1">这是咋回事</h3>

<p>理解这个的关键点,在于理解函数的返回值变了.函数返回的并不是我们认为的NULL, yield关键词使得PHP解释器引擎让这个方法返回了一个Generator类.这个类实现了Iterator迭代器,所以可以直接拿来迭代:</p>

<pre><code class="language-php">foreach (getLines(&quot;someFile&quot;) as $line) {
    doSomethingWithLine($line);
}
</code></pre>

<p>最棒的点在于,我们可以任意的组织代码结构,只需要在我们想返回迭代值的地方&quot;yield&quot;就好了.这是咋个原理呢?首先,当调用getLines()方法时,PHP会执行方法,直到遇到第一个yield,在这个地方停住,记住那个值,然后返回generator对象实例.接下来,对这个Generator对象调用next()方法的时候(可能是循环调用,或者手动调用),PHP会从yield暂定的地方,再次执行迭代器内的代码,直到遇到下一个yield(或者遇到一个return来结束掉方法).了解到这些,我们就可以写一个很有用的Generator了</p>

<pre><code class="language-php">function doStuff() {
    $last = 0;
    $current = 1;
    yield 1;
    while (true) {
        $current = $last + $current;
        $last = $current - $last;
        yield $current;
    }
}
</code></pre>

<p>你能看出来这是做什么的么?第一眼看上去,方法会无限循环下去.实际上,也可以这样.仔细看的话,这是一个很简单的实现了斐波那契数列的方法.</p>

<p>说明一下,这不是一个iterator迭代器的替换版本,这是一个简化版本.Iterator迭代器依然很有用,尤其是在一些结果集类里面,有很多状态需要管理的时候.但是yield确实是非常有用的一个创建迭代器的方式.</p>

<h3 id="toc_2">更复杂的例子</h3>

<p>假设我们想实现一个ArrayObject.除了可以通过iterator迭代器和手动处理数组迭代的方式,我们还可以用一点技巧.IteratorAggregate接口需要一个方法,getIterator().因为这个生成器方法需要返回一个对象,我们就可以让getIterator()变成一个Generator.简单感受一下:</p>

<pre><code class="language-php">class ArrayObject implements IteratorAggregate {
    protected $array;
    public function __construct(array $array) {
        $this-&gt;array = $array;
    }
    public function getIterator() {
        foreach ($this-&gt;array as $key =&gt; $value) {
            yield $key =&gt; $value;
        }
    }
}
</code></pre>

<p>很简单,含义清晰,很容易理解.并且,我们还可以通过传统的Key=&gt;value语法返回一个自定义的key.这里面包含了一系列复杂的逻辑(处理各种状态),通过语言提供的语法糖,我们可以写的很优雅.这样我们就可以更集中精神处理主线逻辑,而不用写出一坨坨的代码.<br/>
但是还有更多可能...</p>

<h3 id="toc_3">回传数据</h3>

<p>我们还可以把数据传回给Generator方法.通过send()方法,yield可以接收到传进来的值.在某些情况下,这个特性非常有用.来看个例子,想要记录一些log数据.除了写一个复杂的log类,单独管理每个状态,用Generator就很简单了.</p>

<pre><code class="language-php">function createLog($file) {
    $f = fopen($file, &#39;a&#39;);
    while (true) {
        $line = yield;
        fwrite($f, $line);
    }
}
$log = createLog($file);
$log-&gt;send(&quot;First&quot;);
$log-&gt;send(&quot;Second&quot;);
$log-&gt;send(&quot;Third&quot;);
</code></pre>

<p>很简单吧.再来看一个复杂点的例子,协程的用法(一起工作的子程序,会来回地进行控制权限的调度).假设我们要构建一个抓取数据的队列系统,在抓取任务间来回地传递数据,可能有二进制的数据流,在数据内集成了长度信息.我们可以手动的把它们组合在一起,也可以构建一系列的Generator:</p>

<pre><code class="language-php">function fetchBytesFromFile($file) {
    $length = yield;
    $f = fopen($file, &#39;r&#39;);
    while (!feof($f)) {
        $length = yield fread($f, $length);
    }
    yield false;
}
function processBytesInBatch(Generator $byteGenerator) {
    $buffer = &#39;&#39;;
    $bytesNeeded = 1000;
    while ($buffer .= $byteGenerator-&gt;send($bytesNeeded)) {
        // determine if buffer has enough data to be executed
        list($lengthOfRecord) = unpack(&#39;N&#39;, $buffer);
        if (strlen($buffer) &lt; $lengthOfRecord) {
            $bytesNeeded = $lengthOfRecord - strlen($buffer);
            continue;
        }
        yield substr($buffer, 1, $lengthOfRecord);
        $buffer = substr($buffer, 0, $lengthOfRecord + 1);
        $bytesNeeded = 1000 - strlen($buffer);
    }
}
$gen = processBytesInBatch(fetchBytesFromFile($file));
foreach ($gen as $record) {
    doSomethingWithRecord($record);
}
</code></pre>

<p>略微复杂,但是希望你还是研究一下具体在做什么.我们把从缓存获取数据和处理的过程抽象了出来.借此,我们可以高效地获取我们需要的数据,同时也没有损失可重用性.</p>

<h3 id="toc_4">其他用处</h3>

<p>Generators还有很多其他用处.非常牛逼有用的一点就是用来模拟线程.基本上,把每个Generator都可以看成&quot;线程&quot;,然后 &quot;yield&quot;把执行上下文传回给调度器,然后调度器继续执行其他子线程(基本上这就是绿色线程 的工作模式).所以我们就可以构建一个从多个数据源同时处理数据的系统(并且可以用非阻塞I/O).一个简单的栗子:</p>

<pre><code class="language-php">function step1() {
    $f = fopen(&quot;file.txt&quot;, &#39;r&#39;);
    while ($line = fgets($f)) {
        processLine($line);
        yield true;
    }
}
function step2() {
    $f = fopen(&quot;file2.txt&quot;, &#39;r&#39;);
    while ($line = fgets($f)) {
        processLine($line);
        yield true;
    }
}
function step3() {
    $f = fsockopen(&quot;www.example.com&quot;, 80);
    stream_set_blocking($f, false);
    $headers = &quot;GET / HTTP/1.1\r\n&quot;;
    $headers .= &quot;Host: www.example.com\r\n&quot;;
    $headers .= &quot;Connection: Close\r\n\r\n&quot;;
    fwrite($f, $headers);
    $body = &#39;&#39;;
    while (!feof($f)) {
        $body .= fread($f, 8192);
        yield true;
    }
    processBody($body);
}
function runner(array $steps) {
    while (true) {
        foreach ($steps as $key =&gt; $step) {
             $step-&gt;next();
             if (!$step-&gt;valid()) {
                 unset($steps[$key]);
             }
        }
        if (empty($steps)) return;
    }
}
runner(array(step1(), step2(), step3()));
</code></pre>

<p>记住,所有用Generator能实现的,用Iterator迭代器都能实现.所以这不是非常特别的能力.但是关键点在于,每一个步骤之间的状态都由引擎来帮我们管理了,所以我们不需要做更多复杂的操作.把面向过程的函数转换为这种模式,只需在把数据传回给父级调用方的时候添加一个yield语句就行了.</p>

<h3 id="toc_5">结论</h3>

<p>迭代器是非常有用的概念.他们能极大地简化代码.想象一下,用一行代码写一个xrange()函数:</p>

<pre><code class="language-php">function xrange($min, $max) {
    for ($i = $min; $i &lt; $max; $i++) yield $i;
}
</code></pre>

<p>简单明了,很容易看懂,性能也很好(比迭代实现的版本好多了).更美好的是,Generator给我们的思路打开了一扇门.更多的用法后面在介绍了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解矩阵]]></title>
    <link href="blog.v2cb.com/15936798966495.html"/>
    <updated>2020-07-02T16:51:36+08:00</updated>
    <id>blog.v2cb.com/15936798966495.html</id>
    <content type="html"><![CDATA[
<p>最近开始研究推荐算法,发现绕不过去的还是线性代数.<br/>
CSDN的孟岩老板讲的这篇非常好.收藏一下.</p>

<p>原文地址:<a href="https://blog.csdn.net/myan/article/details/647511">https://blog.csdn.net/myan/article/details/647511</a></p>

<p>理解矩阵（一）</p>

<p>前不久chensh出于不可告人的目的，要充当老师，教别人线性代数。于是我被揪住就线性代数中一些务虚性的问题与他讨论了几次。很明显，chensh觉得，要让自己在讲线性代数的时候不被那位强势的学生认为是神经病，还是比较难的事情。</p>

<p>可怜的chensh，谁让你趟这个地雷阵？！色令智昏啊！</p>

<p>线性代数课程，无论你从行列式入手还是直接从矩阵入手，从一开始就充斥着莫名其妙。比如说，在全国一般工科院系教学中应用最广泛的同济线性代数教材（现在到了第四版），一上来就介绍逆序数这个“前无古人，后无来者”的古怪概念，然后用逆序数给出行列式的一个极不直观的定义，接着是一些简直犯傻的行列式性质和习题——把这行乘一个系数加到另一行上，再把那一列减过来，折腾得那叫一个热闹，可就是压根看不出这个东西有嘛用。大多数像我一样资质平庸的学生到这里就有点犯晕：连这是个什么东西都模模糊糊的，就开始钻火圈表演了，这未免太“无厘头”了吧！于是开始有人逃课，更多的人开始抄作业。这下就中招了，因为其后的发展可以用一句峰回路转来形容，紧跟着这个无厘头的行列式的，是一个同样无厘头但是伟大的无以复加的家伙的出场——矩阵来了！多年之后，我才明白，当老师犯傻似地用中括号把一堆傻了吧叽的数括起来，并且不紧不慢地说：“这个东西叫做矩阵”的时候，我的数学生涯掀开了何等悲壮辛酸、惨绝人寰的一幕！自那以后，在几乎所有跟“学问”二字稍微沾点边的东西里，矩阵这个家伙从不缺席。对于我这个没能一次搞定线性代数的笨蛋来说，矩阵老大的不请自来每每搞得我灰头土脸，头破血流。长期以来，我在阅读中一见矩阵，就如同阿Q见到了假洋鬼子，揉揉额角就绕道走。</p>

<p>事实上，我并不是特例。一般工科学生初学线性代数，通常都会感到困难。这种情形在国内外皆然。瑞典数学家Lars Garding在其名著Encounter with Mathematics中说：“如果不熟悉线性代数的概念，要去学习自然科学，现在看来就和文盲差不多。”，然而“按照现行的国际标准，线性代数是通过公理化来表述的，它是第二代数学模型，...，这就带来了教学上的困难。”事实上，当我们开始学习线性代数的时候，不知不觉就进入了“第二代数学模型”的范畴当中，这意味着数学的表述方式和抽象性有了一次全面的进化，对于从小一直在“第一代数学模型”，即以实用为导向的、具体的数学模型中学习的我们来说，在没有并明确告知的情况下进行如此剧烈的paradigm shift，不感到困难才是奇怪的。</p>

<p>大部分工科学生，往往是在学习了一些后继课程，如数值分析、数学规划、矩阵论之后，才逐渐能够理解和熟练运用线性代数。即便如此，不少人即使能够很熟练地以线性代数为工具进行科研和应用工作，但对于很多这门课程的初学者提出的、看上去是很基础的问题却并不清楚。比如说：</p>

<ul>
<li><p>矩阵究竟是什么东西？向量可以被认为是具有n个相互独立的性质（维度）的对象的表示，矩阵又是什么呢？我们如果认为矩阵是一组列（行）向量组成的新的复合向量的展开式，那么为什么这种展开式具有如此广泛的应用？特别是，为什么偏偏二维的展开式如此有用？如果矩阵中每一个元素又是一个向量，那么我们再展开一次，变成三维的立方阵，是不是更有用？</p></li>
<li><p>矩阵的乘法规则究竟为什么这样规定？为什么这样一种怪异的乘法规则却能够在实践中发挥如此巨大的功效？很多看上去似乎是完全不相关的问题，最后竟然都归结到矩阵的乘法，这难道不是很奇妙的事情？难道在矩阵乘法那看上去莫名其妙的规则下面，包含着世界的某些本质规律？如果是的话，这些本质规律是什么？</p></li>
<li><p>行列式究竟是一个什么东西？为什么会有如此怪异的计算规则？行列式与其对应方阵本质上是什么关系？为什么只有方阵才有对应的行列式，而一般矩阵就没有（不要觉得这个问题很蠢，如果必要，针对m x n矩阵定义行列式不是做不到的，之所以不做，是因为没有这个必要，但是为什么没有这个必要）？而且，行列式的计算规则，看上去跟矩阵的任何计算规则都没有直观的联系，为什么又在很多方面决定了矩阵的性质？难道这一切仅是巧合？</p></li>
<li><p>矩阵为什么可以分块计算？分块计算这件事情看上去是那么随意，为什么竟是可行的？</p></li>
<li><p>对于矩阵转置运算AT，有(AB)T = BTAT，对于矩阵求逆运算A-1，有(AB)-1 = B-1A-1。两个看上去完全没有什么关系的运算，为什么有着类似的性质？这仅仅是巧合吗？</p></li>
<li><p>为什么说P-1AP得到的矩阵与A矩阵“相似”？这里的“相似”是什么意思？</p></li>
<li><p>特征值和特征向量的本质是什么？它们定义就让人很惊讶，因为Ax =λx，一个诺大的矩阵的效应，竟然不过相当于一个小小的数λ，确实有点奇妙。但何至于用“特征”甚至“本征”来界定？它们刻划的究竟是什么？</p></li>
</ul>

<p>这样的一类问题，经常让使用线性代数已经很多年的人都感到为难。就好像大人面对小孩子的刨根问底，最后总会迫不得已地说“就这样吧，到此为止”一样，面对这样的问题，很多老手们最后也只能用：“就是这么规定的，你接受并且记住就好”来搪塞。然而，这样的问题如果不能获得回答，线性代数对于我们来说就是一个粗暴的、不讲道理的、莫名其妙的规则集合，我们会感到，自己并不是在学习一门学问，而是被不由分说地“抛到”一个强制的世界中，只是在考试的皮鞭挥舞之下被迫赶路，全然无法领略其中的美妙、和谐与统一。直到多年以后，我们已经发觉这门学问如此的有用，却仍然会非常迷惑：怎么这么凑巧？</p>

<p>我认为，这是我们的线性代数教学中直觉性丧失的后果。上述这些涉及到“如何能”、“怎么会”的问题，仅仅通过纯粹的数学证明来回答，是不能令提问者满意的。比如，如果你通过一般的证明方法论证了矩阵分块运算确实可行，那么这并不能够让提问者的疑惑得到解决。他们真正的困惑是：矩阵分块运算为什么竟然是可行的？究竟只是凑巧，还是说这是由矩阵这种对象的某种本质所必然决定的？如果是后者，那么矩阵的这些本质是什么？只要对上述那些问题稍加考虑，我们就会发现，所有这些问题都不是单纯依靠数学证明所能够解决的。像我们的教科书那样，凡事用数学证明，最后培养出来的学生，只能熟练地使用工具，却欠缺真正意义上的理解。</p>

<p>自从1930年代法国布尔巴基学派兴起以来，数学的公理化、系统性描述已经获得巨大的成功，这使得我们接受的数学教育在严谨性上大大提高。然而数学公理化的一个备受争议的副作用，就是一般数学教育中直觉性的丧失。数学家们似乎认为直觉性与抽象性是矛盾的，因此毫不犹豫地牺牲掉前者。然而包括我本人在内的很多人都对此表示怀疑，我们不认为直觉性与抽象性一定相互矛盾，特别是在数学教育中和数学教材中，帮助学生建立直觉，有助于它们理解那些抽象的概念，进而理解数学的本质。反之，如果一味注重形式上的严格性，学生就好像被迫进行钻火圈表演的小白鼠一样，变成枯燥的规则的奴隶。</p>

<p>对于线性代数的类似上述所提到的一些直觉性的问题，两年多来我断断续续地反复思考了四、五次，为此阅读了好几本国内外线性代数、数值分析、代数和数学通论性书籍，其中像前苏联的名著《数学：它的内容、方法和意义》、龚昇教授的《线性代数五讲》、前面提到的Encounter with Mathematics（《数学概观》）以及Thomas A. Garrity的《数学拾遗》都给我很大的启发。不过即使如此，我对这个主题的认识也经历了好几次自我否定。比如以前思考的一些结论曾经写在自己的blog里，但是现在看来，这些结论基本上都是错误的。因此打算把自己现在的有关理解比较完整地记录下来，一方面是因为我觉得现在的理解比较成熟了，可以拿出来与别人探讨，向别人请教。另一方面，如果以后再有进一步的认识，把现在的理解给推翻了，那现在写的这个snapshot也是很有意义的。</p>

<p>因为打算写得比较多，所以会分几次慢慢写。也不知道是不是有时间慢慢写完整，会不会中断，写着看吧。</p>

<hr/>

<p>今天先谈谈对线形空间和矩阵的几个核心概念的理解。这些东西大部分是凭着自己的理解写出来的，基本上不抄书，可能有错误的地方，希望能够被指出。但我希望做到直觉，也就是说能把数学背后说的实质问题说出来。</p>

<p>首先说说空间(space)，这个概念是现代数学的命根子之一，从拓扑空间开始，一步步往上加定义，可以形成很多空间。线形空间其实还是比较初级的，如果在里面定义了范数，就成了赋范线性空间。赋范线性空间满足完备性，就成了巴那赫空间；赋范线性空间中定义角度，就有了内积空间，内积空间再满足完备性，就得到希尔伯特空间。</p>

<p>总之，空间有很多种。你要是去看某种空间的数学定义，大致都是“存在一个集合，在这个集合上定义某某概念，然后满足某些性质”，就可以被称为空间。这未免有点奇怪，为什么要用“空间”来称呼一些这样的集合呢？大家将会看到，其实这是很有道理的。</p>

<p>我们一般人最熟悉的空间，毫无疑问就是我们生活在其中的（按照牛顿的绝对时空观）的三维空间，从数学上说，这是一个三维的欧几里德空间，我们先不管那么多，先看看我们熟悉的这样一个空间有些什么最基本的特点。仔细想想我们就会知道，这个三维的空间：1. 由很多（实际上是无穷多个）位置点组成；2. 这些点之间存在相对的关系；3. 可以在空间中定义长度、角度；4. 这个空间可以容纳运动，这里我们所说的运动是从一个点到另一个点的移动（变换），而不是微积分意义上的“连续”性的运动，</p>

<p>上面的这些性质中，最最关键的是第4条。第1、2条只能说是空间的基础，不算是空间特有的性质，凡是讨论数学问题，都得有一个集合，大多数还得在这个集合上定义一些结构（关系），并不是说有了这些就算是空间。而第3条太特殊，其他的空间不需要具备，更不是关键的性质。只有第4条是空间的本质，也就是说，容纳运动是空间的本质特征。</p>

<p>认识到了这些，我们就可以把我们关于三维空间的认识扩展到其他的空间。事实上，不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。你会发现，在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。</p>

<p>因此只要知道，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。</p>

<p>下面我们来看看线性空间。线性空间的定义任何一本书上都有，但是既然我们承认线性空间是个空间，那么有两个最基本的问题必须首先得到解决，那就是：</p>

<ol>
<li><p>空间是一个对象集合，线性空间也是空间，所以也是一个对象集合。那么线性空间是什么样的对象的集合？或者说，线性空间中的对象有什么共同点吗？</p></li>
<li><p>线性空间中的运动如何表述的？也就是，线性变换是如何表示的？</p></li>
</ol>

<p>我们先来回答第一个问题，回答这个问题的时候其实是不用拐弯抹角的，可以直截了当的给出答案。线性空间中的任何一个对象，通过选取基和坐标的办法，都可以表达为向量的形式。通常的向量空间我就不说了，举两个不那么平凡的例子：</p>

<p>L1. 最高次项不大于n次的多项式的全体构成一个线性空间，也就是说，这个线性空间中的每一个对象是一个多项式。如果我们以x0, x1, ..., xn为基，那么任何一个这样的多项式都可以表达为一组n+1维向量，其中的每一个分量ai其实就是多项式中x(i-1)项的系数。值得说明的是，基的选取有多种办法，只要所选取的那一组基线性无关就可以。这要用到后面提到的概念了，所以这里先不说，提一下而已。</p>

<p>L2. 闭区间[a, b]上的n阶连续可微函数的全体，构成一个线性空间。也就是说，这个线性空间的每一个对象是一个连续函数。对于其中任何一个连续函数，根据魏尔斯特拉斯定理，一定可以找到最高次项不大于n的多项式函数，使之与该连续函数的差为0，也就是说，完全相等。这样就把问题归结为L1了。后面就不用再重复了。</p>

<p>所以说，向量是很厉害的，只要你找到合适的基，用向量可以表示线性空间里任何一个对象。这里头大有文章，因为向量表面上只是一列数，但是其实由于它的有序性，所以除了这些数本身携带的信息之外，还可以在每个数的对应位置上携带信息。为什么在程序设计中数组最简单，却又威力无穷呢？根本原因就在于此。这是另一个问题了，这里就不说了。</p>

<p>下面来回答第二个问题，这个问题的回答会涉及到线性代数的一个最根本的问题。</p>

<p>线性空间中的运动，被称为线性变换。也就是说，你从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。那么，线性变换如何表示呢？很有意思，在线性空间中，当你选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。</p>

<p>简而言之，在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。</p>

<p>是的，矩阵的本质是运动的描述。如果以后有人问你矩阵是什么，那么你就可以响亮地告诉他，矩阵的本质是运动的描述。（chensh，说你呢！）</p>

<p>可是多么有意思啊，向量本身不是也可以看成是n x 1矩阵吗？这实在是很奇妙，一个空间中的对象和运动竟然可以用相类同的方式表示。能说这是巧合吗？如果是巧合的话，那可真是幸运的巧合！可以说，线性代数中大多数奇妙的性质，均与这个巧合有直接的关系。</p>

<p>理解矩阵（二）</p>

<p>接着理解矩阵。</p>

<p>上一篇里说“矩阵是运动的描述”，到现在为止，好像大家都还没什么意见。但是我相信早晚会有数学系出身的网友来拍板转。因为运动这个概念，在数学和物理里是跟微积分联系在一起的。我们学习微积分的时候，总会有人照本宣科地告诉你，初等数学是研究常量的数学，是研究静态的数学，高等数学是变量的数学，是研究运动的数学。大家口口相传，差不多人人都知道这句话。但是真知道这句话说的是什么意思的人，好像也不多。简而言之，在我们人类的经验里，运动是一个连续过程，从A点到B点，就算走得最快的光，也是需要一个时间来逐点地经过AB之间的路径，这就带来了连续性的概念。而连续这个事情，如果不定义极限的概念，根本就解释不了。古希腊人的数学非常强，但就是缺乏极限观念，所以解释不了运动，被芝诺的那些著名悖论（飞箭不动、飞毛腿阿喀琉斯跑不过乌龟等四个悖论）搞得死去活来。因为这篇文章不是讲微积分的，所以我就不多说了。有兴趣的读者可以去看看齐民友教授写的《重温微积分》。我就是读了这本书开头的部分，才明白“高等数学是研究运动的数学”这句话的道理。</p>

<p>不过在我这个《理解矩阵》的文章里，“运动”的概念不是微积分中的连续性的运动，而是瞬间发生的变化。比如这个时刻在A点，经过一个“运动”，一下子就“跃迁”到了B点，其中不需要经过A点与B点之间的任何一个点。这样的“运动”，或者说“跃迁”，是违反我们日常的经验的。不过了解一点量子物理常识的人，就会立刻指出，量子（例如电子）在不同的能量级轨道上跳跃，就是瞬间发生的，具有这样一种跃迁行为。所以说，自然界中并不是没有这种运动现象，只不过宏观上我们观察不到。但是不管怎么说，“运动”这个词用在这里，还是容易产生歧义的，说得更确切些，应该是“跃迁”。因此这句话可以改成：</p>

<p>“矩阵是线性空间里跃迁的描述”。</p>

<p>可是这样说又太物理，也就是说太具体，而不够数学，也就是说不够抽象。因此我们最后换用一个正牌的数学术语——变换，来描述这个事情。这样一说，大家就应该明白了，所谓变换，其实就是空间里从一个点（元素/对象）到另一个点（元素/对象）的跃迁。比如说，拓扑变换，就是在拓扑空间里从一个点到另一个点的跃迁。再比如说，仿射变换，就是在仿射空间里从一个点到另一个点的跃迁。附带说一下，这个仿射空间跟向量空间是亲兄弟。做计算机图形学的朋友都知道，尽管描述一个三维对象只需要三维向量，但所有的计算机图形学变换矩阵都是4 x 4的。说其原因，很多书上都写着“为了使用中方便”，这在我看来简直就是企图蒙混过关。真正的原因，是因为在计算机图形学里应用的图形变换，实际上是在仿射空间而不是向量空间中进行的。想想看，在向量空间里相一个向量平行移动以后仍是相同的那个向量，而现实世界等长的两个平行线段当然不能被认为同一个东西，所以计算机图形学的生存空间实际上是仿射空间。而仿射变换的矩阵表示根本就是4 x 4的。又扯远了，有兴趣的读者可以去看《计算机图形学——几何工具算法详解》。</p>

<p>一旦我们理解了“变换”这个概念，矩阵的定义就变成：</p>

<p>“矩阵是线性空间里的变换的描述。”</p>

<p>到这里为止，我们终于得到了一个看上去比较数学的定义。不过还要多说几句。教材上一般是这么说的，在一个线性空间V里的一个线性变换T，当选定一组基之后，就可以表示为矩阵。因此我们还要说清楚到底什么是线性变换，什么是基，什么叫选定一组基。线性变换的定义是很简单的，设有一种变换T，使得对于线性空间V中间任何两个不相同的对象x和y，以及任意实数a和b，有：<br/>
T(ax + by) = aT(x) + bT(y)，<br/>
那么就称T为线性变换。</p>

<p>定义都是这么写的，但是光看定义还得不到直觉的理解。线性变换究竟是一种什么样的变换？我们刚才说了，变换是从空间的一个点跃迁到另一个点，而线性变换，就是从一个线性空间V的某一个点跃迁到另一个线性空间W的另一个点的运动。这句话里蕴含着一层意思，就是说一个点不仅可以变换到同一个线性空间中的另一个点，而且可以变换到另一个线性空间中的另一个点去。不管你怎么变，只要变换前后都是线性空间中的对象，这个变换就一定是线性变换，也就一定可以用一个非奇异矩阵来描述。而你用一个非奇异矩阵去描述的一个变换，一定是一个线性变换。有的人可能要问，这里为什么要强调非奇异矩阵？所谓非奇异，只对方阵有意义，那么非方阵的情况怎么样？这个说起来就会比较冗长了，最后要把线性变换作为一种映射，并且讨论其映射性质，以及线性变换的核与像等概念才能彻底讲清楚。我觉得这个不算是重点，如果确实有时间的话，以后写一点。以下我们只探讨最常用、最有用的一种变换，就是在同一个线性空间之内的线性变换。也就是说，下面所说的矩阵，不作说明的话，就是方阵，而且是非奇异方阵。学习一门学问，最重要的是把握主干内容，迅速建立对于这门学问的整体概念，不必一开始就考虑所有的细枝末节和特殊情况，自乱阵脚。</p>

<p>接着往下说，什么是基呢？这个问题在后面还要大讲一番，这里只要把基看成是线性空间里的坐标系就可以了。注意是坐标系，不是坐标值，这两者可是一个“对立矛盾统一体”。这样一来，“选定一组基”就是说在线性空间里选定一个坐标系。就这意思。</p>

<p>好，最后我们把矩阵的定义完善如下：</p>

<p>“矩阵是线性空间中的线性变换的一个描述。在一个线性空间中，只要我们选定一组基，那么对于任何一个线性变换，都能够用一个确定的矩阵来加以描述。”</p>

<p>理解这句话的关键，在于把“线性变换”与“线性变换的一个描述”区别开。一个是那个对象，一个是对那个对象的表述。就好像我们熟悉的面向对象编程中，一个对象可以有多个引用，每个引用可以叫不同的名字，但都是指的同一个对象。如果还不形象，那就干脆来个很俗的类比。</p>

<p>比如有一头猪，你打算给它拍照片，只要你给照相机选定了一个镜头位置，那么就可以给这头猪拍一张照片。这个照片可以看成是这头猪的一个描述，但只是一个片面的的描述，因为换一个镜头位置给这头猪拍照，能得到一张不同的照片，也是这头猪的另一个片面的描述。所有这样照出来的照片都是这同一头猪的描述，但是又都不是这头猪本身。</p>

<p>同样的，对于一个线性变换，只要你选定一组基，那么就可以找到一个矩阵来描述这个线性变换。换一组基，就得到一个不同的矩阵。所有这些矩阵都是这同一个线性变换的描述，但又都不是线性变换本身。</p>

<p>但是这样的话，问题就来了如果你给我两张猪的照片，我怎么知道这两张照片上的是同一头猪呢？同样的，你给我两个矩阵，我怎么知道这两个矩阵是描述的同一个线性变换呢？如果是同一个线性变换的不同的矩阵描述，那就是本家兄弟了，见面不认识，岂不成了笑话。</p>

<p>好在，我们可以找到同一个线性变换的矩阵兄弟们的一个性质，那就是：</p>

<p>若矩阵A与B是同一个线性变换的两个不同的描述（之所以会不同，是因为选定了不同的基，也就是选定了不同的坐标系），则一定能找到一个非奇异矩阵P，使得A、B之间满足这样的关系：</p>

<p>A = P-1BP</p>

<p>线性代数稍微熟一点的读者一下就看出来，这就是相似矩阵的定义。没错，所谓相似矩阵，就是同一个线性变换的不同的描述矩阵。按照这个定义，同一头猪的不同角度的照片也可以成为相似照片。俗了一点，不过能让人明白。</p>

<p>而在上面式子里那个矩阵P，其实就是A矩阵所基于的基与B矩阵所基于的基这两组基之间的一个变换关系。关于这个结论，可以用一种非常直觉的方法来证明（而不是一般教科书上那种形式上的证明），如果有时间的话，我以后在blog里补充这个证明。</p>

<p>这个发现太重要了。原来一族相似矩阵都是同一个线性变换的描述啊！难怪这么重要！工科研究生课程中有矩阵论、矩阵分析等课程，其中讲了各种各样的相似变换，比如什么相似标准型，对角化之类的内容，都要求变换以后得到的那个矩阵与先前的那个矩阵式相似的，为什么这么要求？因为只有这样要求，才能保证变换前后的两个矩阵是描述同一个线性变换的。当然，同一个线性变换的不同矩阵描述，从实际运算性质来看并不是不分好环的。有些描述矩阵就比其他的矩阵性质好得多。这很容易理解，同一头猪的照片也有美丑之分嘛。所以矩阵的相似变换可以把一个比较丑的矩阵变成一个比较美的矩阵，而保证这两个矩阵都是描述了同一个线性变换。</p>

<p>这样一来，矩阵作为线性变换描述的一面，基本上说清楚了。但是，事情没有那么简单，或者说，线性代数还有比这更奇妙的性质，那就是，矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。</p>

<p>这个留在下一篇再写吧。</p>

<p>因为有别的事情要做，下一篇可能要过几天再写了。</p>

<p>理解矩阵（三）</p>

<p>这两篇文章发表于去年的4月。在第二部分结束的时候，我说：<br/>
“矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而 作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点 与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。<br/>
这个留在下一篇再写吧。</p>

<p>因为有别的事情要做，下一篇可能要过几天再写了。 ”</p>

<p>然而这一拖就是一年半。一年半以来，这两篇粗糙放肆的文章被到处转载，以至于在Google的搜索提示中，我的名字跟“矩阵”是一对关联词汇。这对于学生时代数学一直很差的我来说，实在是令人惶恐的事情。数学是何等辉煌精致的学问！代表着人类智慧的最高成就，是人与上帝对话的语言。而我实在连数学的门都还没进去，不要说谈什么理解，就是稍微难一些的题目我也很少能解开。我有什么资格去谈矩阵这样重要的一个数学概念呢？更何况，我的想法直观是直观，未见的是正确的啊，会不会误人子弟呢？因此，算了吧，到此为止吧，我这么想。</p>

<p>        是时不时收到的来信逐渐改变了我的想法。</p>

<p>        一年半以来，我收到过不下一百封直接的来信，要求我把后面的部分写出来。这些来信大部分是国内的网友和学生，也有少数来自正在国外深造的朋友，大部分是鼓励，有的是诚挚的请求，也有少数严厉斥责我不守承诺。不管是何种态度，这都表明他们对我这一点点小小的思考成果的鼓励，特别是对于我这种思维的视角和尝试的鼓励。他们在信中让我知道，尽管我的数学水平不高，但是我这种从普通人（而不是数学家）视角出发，强调对数学概念和规则的直觉理解的思路，对于很多人是有益的。也许这条路子在数学中绝非正道，也不会走得很远，但是无论如何，在一定的阶段，对一部分人来说，较之目前数学教材普遍采用的思路，这种方式可能更容易理解一些。既然是可能对一部分人有帮助的事情，那么我就不应该心存太多杂念，应该不断思考和总结下去。</p>

<p>       所以，下面就是你们来信要求我写出来的东西。</p>

<p>       首先来总结一下前面两部分的一些主要结论：</p>

<ol>
<li>首先有空间，空间可以容纳对象运动的。一种空间对应一类对象。</li>
<li>有一种空间叫线性空间，线性空间是容纳向量对象运动的。</li>
<li>运动是瞬时的，因此也被称为变换。</li>
<li>矩阵是线性空间中运动（变换）的描述。</li>
<li>矩阵与向量相乘，就是实施运动（变换）的过程。</li>
<li>同一个变换，在不同的坐标系下表现为不同的矩阵，但是它们的本质是一样的，所以本征值相同。</li>
</ol>

<p>        下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量，而向量是这么表示的：</p>

<p>        [a1, a2, a3, ..., an]</p>

<p>       矩阵呢？矩阵是这么表示的：</p>

<p>        a11, a12, a13, ..., a1n<br/>
        a21, a22, a23, ..., a2n<br/>
                     ...<br/>
        an1, an2, an3, ..., ann</p>

<p>        不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在这里只讨论这个n阶的、非奇异的方阵，因为理解它就是理解矩阵的关键，它才是一般情况，而其他矩阵都是意外，都是不得不对付的讨厌状况，大可以放在一边。这里多一句嘴，学习东西要抓住主流，不要纠缠于旁支末节。很可惜我们的教材课本大多数都是把主线埋没在细节中的，搞得大家还没明白怎么回事就先被灌晕了。比如数学分析，明明最要紧的观念是说，一个对象可以表达为无穷多个合理选择的对象的线性和，这个概念是贯穿始终的，也是数学分析的精华。但是课本里自始至终不讲这句话，反正就是让你做吉米多维奇，掌握一大堆解偏题的技巧，记住各种特殊情况，两类间断点，怪异的可微和可积条件（谁还记得柯西条件、迪里赫莱条件...？），最后考试一过，一切忘光光。要我说，还不如反复强调这一个事情，把它深深刻在脑子里，别的东西忘了就忘了，真碰到问题了，再查数学手册嘛，何必因小失大呢？</p>

<p>        言归正传。如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。</p>

<p>        现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么组成这个矩阵的那一组向量也就是线性无关的了，也就可以成为度量线性空间的一个坐标系。结论：矩阵描述了一个坐标系。</p>

<p>        “慢着！”，你嚷嚷起来了，“你这个骗子！你不是说过，矩阵就是运动吗？怎么这会矩阵又是坐标系了？”</p>

<p>        嗯，所以我说到了关键的一步。我并没有骗人，之所以矩阵又是运动，又是坐标系，那是因为——</p>

<p>        “运动等价于坐标系变换”。</p>

<p>        对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：</p>

<p>       “对象的变换等价于坐标系的变换”。</p>

<p>       或者：</p>

<p>       “固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换。”</p>

<p>       说白了就是：</p>

<p>        “运动是相对的。”        </p>

<p>        让我们想想，达成同一个变换的结果，比如把点(1, 1)变到点(2, 3)去，你可以有两种做法。第一，坐标系不动，点动，把(1, 1)点挪到(2, 3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2, 3)了。方式不同，结果一样。</p>

<p>        从第一个方式来看，那就是我在《理解矩阵》1/2中说的，把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。在这个方式下，</p>

<p>       Ma = b</p>

<p>       的意思是：</p>

<p>       “向量a经过矩阵M所描述的变换，变成了向量b。”</p>

<p>        而从第二个方式来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：</p>

<p>        Ma = b</p>

<p>       的意思是：</p>

<p>        “有一个向量，它在坐标系M的度量下得到的度量结果向量为a，那么它在坐标系I的度量下，这个向量的度量结果是b。”</p>

<p>        这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。</p>

<p>        而这两个方式本质上是等价的。</p>

<p>        我希望你务必理解这一点，因为这是本篇的关键。</p>

<p>        正因为是关键，所以我得再解释一下。</p>

<p>        在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说：</p>

<p>        “注意了！这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。”</p>

<p>       那么我们再看孤零零的向量b：</p>

<p>       b</p>

<p>       多看几遍，你没看出来吗？它其实不是b，它是：</p>

<p>       Ib</p>

<p>       也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”</p>

<p>       而  Ma = Ib的意思就是说：</p>

<p>       “在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”</p>

<p>       这哪里是什么乘法计算，根本就是身份识别嘛。</p>

<p>       从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。向量还是那个向量，选择的坐标系不同，其表示方式就不同。因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是 Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。我们平时说一个向量是[2 3 5 7]T，隐含着是说，这个向量在 I 坐标系中的度量结果是[2 3 5 7]T，因此，这个形式反而是一种简化了的特殊情况。</p>

<p>        注意到，M矩阵表示出来的那个坐标系，由一组基组成，而那组基也是由向量组成的，同样存在这组向量是在哪个坐标系下度量而成的问题。也就是说，表述一个矩阵的一般方法，也应该要指明其所处的基准坐标系。所谓M，其实是 IM，也就是说，M中那组基的度量是在 I 坐标系中得出的。从这个视角来看，M×N也不是什么矩阵乘法了，而是声明了一个在M坐标系中量出的另一个坐标系N，其中M本身是在I坐标系中度量出来的。</p>

<p>       回过头来说变换的问题。我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？</p>

<p>       请看：</p>

<p>       Ma = Ib</p>

<p>       我现在要变M为I，怎么变？对了，再前面乘以个M-1，也就是M的逆矩阵。换句话说，你不是有一个坐标系M吗，现在我让它乘以个M-1，变成I，这样一来的话，原来M坐标系中的a在I中一量，就得到b了。</p>

<p>       我建议你此时此刻拿起纸笔，画画图，求得对这件事情的理解。比如，你画一个坐标系，x轴上的衡量单位是2，y轴上的衡量单位是3，在这样一个坐标系里，坐标为(1，1)的那一点，实际上就是笛卡尔坐标系里的点(2, 3)。而让它原形毕露的办法，就是把原来那个坐标系:</p>

<p>       2 0<br/>
       0 3</p>

<p>       的x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3，这样一来坐标系就变成单位坐标系I了。保持点不变，那个向量现在就变成了(2, 3)了。</p>

<p>       怎么能够让“x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3”呢？就是让原坐标系：</p>

<p>      2 0<br/>
      0 3</p>

<p>       被矩阵：</p>

<p>       1/2   0<br/>
         0   1/3</p>

<p>       左乘。而这个矩阵就是原矩阵的逆矩阵。</p>

<p>       下面我们得出一个重要的结论：</p>

<p>        “对坐标系施加变换的方法，就是让表示那个坐标系的矩阵与表示那个变化的矩阵相乘。”</p>

<p>        再一次的，矩阵的乘法变成了运动的施加。只不过，被施加运动的不再是向量，而是另一个坐标系。</p>

<p>        如果你觉得你还搞得清楚，请再想一下刚才已经提到的结论，矩阵MxN，一方面表明坐标系N在运动M下的变换结果，另一方面，把M当成N的前缀，当成N的环境描述，那么就是说，在M坐标系度量下，有另一个坐标系N。这个坐标系N如果放在I坐标系中度量，其结果为坐标系MxN。</p>

<p>        在这里，我实际上已经回答了一般人在学习线性代数是最困惑的一个问题，那就是为什么矩阵的乘法要规定成这样。简单地说，是因为：</p>

<p>        1. 从变换的观点看，对坐标系N施加M变换，就是把组成坐标系N的每一个向量施加M变换。</p>

<p>        2. 从坐标系的观点看，在M坐标系中表现为N的另一个坐标系，这也归结为，对N坐标系基的每一个向量，把它在I坐标系中的坐标找出来，然后汇成一个新的矩阵。</p>

<p>        3. 至于矩阵乘以向量为什么要那样规定，那是因为一个在M中度量为a的向量，如果想要恢复在I中的真像，就必须分别与M中的每一个向量进行內积运算。我把这个结论的推导留给感兴趣的朋友吧。应该说，其实到了这一步，已经很容易了。</p>

<p>        综合以上1/2/3，矩阵的乘法就得那么规定，一切有根有据，绝不是哪个神经病胡思乱想出来的。<br/>
 <br/>
        我已经无法说得更多了。矩阵又是坐标系，又是变换。到底是坐标系，还是变换，已经说不清楚了，运动与实体在这里统一了，物质与意识的界限已经消失了，一切归于无法言说，无法定义了。道可道，非常道，名可名，非常名。矩阵是在是不可道之道，不可名之名的东西。到了这个时候，我们不得不承认，我们伟大的线性代数课本上说的矩阵定义，是无比正确的：</p>

<p>        “矩阵就是由m行n列数放在一起组成的数学对象。”</p>

<p>        好了，这基本上就是我想说的全部了。还留下一个行列式的问题。矩阵M的行列式实际上是组成M的各个向量按照平行四边形法则搭成一个n维立方体的体积。对于这一点，我只能感叹于其精妙，却无法揭开其中奥秘了。也许我掌握的数学工具不够，我希望有人能够给我们大家讲解其中的道理了。</p>

<p>        我不知道是否讲得足够清楚了，反正这一部分需要您花些功夫去推敲。</p>

<p>        此外，请大家不必等待这个系列的后续部分。以我的工作情况而言，近期内很难保证继续投入脑力到这个领域中，尽管我仍然对此兴致浓厚。不过如果还有（四）的话，可能是一些站在应用层面的考虑，比如对计算机图形学相关算法的理解。但是我不承诺这些讨论近期内会出现了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# Hyperf源码阅读 第二章 HTTP服务初始化]]></title>
    <link href="blog.v2cb.com/15932480961729.html"/>
    <updated>2020-06-27T16:54:56+08:00</updated>
    <id>blog.v2cb.com/15932480961729.html</id>
    <content type="html"><![CDATA[
<p>Hyperf提供了多种服务器模式,本章以最常用的HTTP服务器的启动流程来进行分析.</p>

<h2 id="toc_0">目录</h2>

<ul>
<li><a href="#start%E5%91%BD%E4%BB%A4">start命令</a>
<ul>
<li><a href="#StartServer">StartServer</a></li>
<li><a href="#ServerFactory">ServerFactory</a></li>
<li><a href="#Server">Server</a></li>
</ul></li>
</ul>

<h3 id="toc_1"><a name="start命令">start命令</a></h3>

<ul>
<li><p><a name="StartServer">Hyperf\Server\Command\StartServer</a><br/><br/>
本类即是start命令对应的Command类.传给parent::_construct()的参数为命令的名字&quot;start&quot;</p>
<ul>
<li>execute()<br/>
执行命令.<br/>
先检查一下swoole相关的配置。<br/>
从容器中拿到ServerFactory,传入config/autoload/server.php中关于server的配置；这个server可以配置多个，可以启动HTTP服务器，RPC服务器，WS服务器等；<br/>
Runtime::enableCoroutine()是swoole相关方法，开启协程；</li>
</ul></li>
<li><p><a name="ServerFactory">Hyperf\Server\ServerFactory</a><br/>
start()方法通过getServer()最终创建了一个Hyperf\Server\Server对象。<br/>
传入了Container依赖，Log依赖，事件分发器EventDispatcher依赖。<br/>
最后调用Server的start()方法。</p></li>
<li><p><a name="Server">Hyperf\Server\Server</a></p>
<ul>
<li>_construct() 很简单，把传入的依赖存起来。</li>
<li>initServers()<br/>
在StartServer-&gt;ServerFactory-&gt;configure()的阶段，调用了本方法，也是开始设置服务回调的阶段，非常重要。</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hyperf源码阅读 第一章 初始化]]></title>
    <link href="blog.v2cb.com/15928236190986.html"/>
    <updated>2020-06-22T19:00:19+08:00</updated>
    <id>blog.v2cb.com/15928236190986.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">目录</h2>

<ul>
<li><a href="#%E5%85%A5%E5%8F%A3">入口 bin/hyperf.php</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E6%A1%86%E6%9E%B6%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6">初始化框架依赖文件 config/container</a>
<ul>
<li><a href="#DefinitionSourceFactory">DefinitionSourceFactory</a></li>
<li><a href="#DefinitionSource">DefinitionSource</a><br/></li>
</ul></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8">初始化容器Container vendor/hyperf/di/src/Container</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%94%E7%94%A8">初始化应用Application vendor/hyperf/framework/src/ApplicationFactory</a>
<ul>
<li><a href="#ApplicationFactory">ApplicationFactory</a></li>
<li><a href="#Application">Application</a></li>
</ul></li>
<li><a href="#%E7%BB%93%E5%B0%BE">结尾</a></li>
</ul>

<h3 id="toc_1"><a name="入口">入口</a></h3>

<p>初始化基本环境: 报错级别, 时区, 基础目录, autoload<br/>
通过一个匿名函数,来初始化整个容器与App,避免了变量污染了全局作用域.</p>

<p>现代化的Web框架,一般都先创建Container容器,通过容器来创建框架初始化需要的全部对象, 最后拿到一个代表框架本身的$application.</p>

<p>define的SWOOLE_HOOK_ALL,是设置swoole的&quot;一键协程化&quot;,把PHP全部的IO函数,通过swoole转化为协程执行,避免阻塞.</p>

<h3 id="toc_2"><a name="初始化框架依赖文件">初始化框架依赖文件</a></h3>

<p>容器的文件在Hyperf\Di\Container,new创建容器对象,传入了一个依赖Hyperf\Di\Definition\DefinitionSourceFactory,这是框架初始化需要用到的依赖.<br/>
注意写法(new DefinitionSourceFactory(true))(),会先调用construct然后调用__invoke()方法.</p>

<ul>
<li><p><a name="DefinitionSourceFactory">DefinitionSourceFactory</a><br/>
从名字看出是一个工厂类,工厂最终生产出的对象是DefinitionSource,是框架初始化真正需要用到的对象.<br/>
在Hyperf中,DefinitionSource这个概念值得提前说一下.每个DefinitionSource对象,代表了一个需要被容器管理的类;在这个DS对象中,保存了目标对象的基本信息,主要是新建类的时候,construct是不是存在,是不是需要注入依赖,是不是有注解定义的依赖,这些依赖又是谁,等等这些创建目标对象时候需要的基础信息.</p>
<ul>
<li>__construct()很简单,设置几个参数.</li>
<li>核心操作在__invoke() 里面.<br/>
整个函数的作用,主要是从框架自己,和每个组件的ProviderConfig里面加载配置,合并成一个大的数组.<br/>
关于框架的ConfigProvider机制详见<a href="https://hyperf.wiki/1.1/#/zh-cn/component-guide/configprovider?id=configprovider-%e6%9c%ba%e5%88%b6">此处</a>,简单来说,每个组件通过一个ConfigProvider.php文件提供一个配置数组,最后在此处 把这个配置数组合并成一个大的配置数组.<br/>
同时,通过注解注入的对象,也在此处进行解析.<br/>
先通过ProviderConfig::load()获取到各个组件里面定义的dependencies,然后跟/autoload/dependencies.php里面的定义进行合并和覆盖.同样在处理annotations注解的扫描路径,都传给ScanConfig对象进行搜索,最后做为依赖一起注入给DefinitionSource.</li>
</ul></li>
<li><p><a name="DefinitionSource">DefinitionSource</a></p>
<ul>
<li><p>__construct() <br/>
$this-&gt;scan()主要是处理注解,进行搜索,处理vendor下面的组件和app目录里的注解.<br/>
通过loadMetadata方法,把扫描到的结果存到AstCollector中,并且生成文件缓存.</p>
<p>紧接着就是初始化框架启动必须的对象</p>
<pre><code class="language-php">$this-&gt;source = $this-&gt;normalizeSource($source);
</code></pre>
<p>$source就是dependencies的配置,各个接口与具体实现类的对应,内容大致如下</p>
<pre><code class="language-php">[
&quot;Psr\SimpleCache\CacheInterface&quot;=&gt; &quot;Hyperf\Cache\Cache&quot;,<br/>
&quot;Hyperf\Contract\ConfigInterface&quot;=&gt; &quot;Hyperf\Config\ConfigFactory&quot;,<br/>
&quot;Hyperf\DbConnection\Pool\PoolFactory&quot;=&gt;&quot;Hyperf\DbConnection\Pool\PoolFactory&quot;,<br/>
&quot;Hyperf\Database\Connectors\ConnectionFactory&quot;=&gt; &quot;Hyperf\Database\Connectors\ConnectionFactory&quot;,<br/>
&quot;Hyperf\Database\ConnectionResolverInterface&quot;=&gt; &quot;Hyperf\DbConnection\ConnectionResolver&quot;,<br/>
&quot;db.connector.mysql&quot;=&gt;  &quot;Hyperf\Database\Connectors\MySqlConnector&quot;,<br/>
...<br/>
]
</code></pre>
<p>normalize 正常化,即为实例化的意思, 把类实例化成为对象.<br/>
通过循环调用normalizeDefinition()来实例化.</p></li>
<li><p>normalizeDefinition()<br/>
实例化对象时分2种情况: 工厂类,非工厂类.实现了 __invoke()或者is_callable()的类为工厂类,返回一个新的FactoryDefinition对象;<br/>
非工厂类,生成一个新的ObjectDefinition对象,交由autowire处理;</p></li>
<li><p>autowire()<br/>
此处开始完善一个类实例化需要的各种参数.<br/>
通过反射ReflectManager拿到类的construct,并通过getParametersDefinition()获取type-hint的结果,拿到construct需要注入的依赖类型;<br/>
通过AnnotationCollector拿到@Inject注解注入的依赖;<br/>
如果需要Proxy的话,设置Proxy;关于AOP参考文档<a href="https://hyperf.wiki/1.1/#/zh-cn/aop?id=aop-%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%bc%96%e7%a8%8b">AOP</a><br/>
经过完善后,返回$definition,一个随时可以被实例化的类的定义.</p></li>
</ul></li>
</ul>

<h3 id="toc_3"><a name="初始化容器">初始化容器Container</a></h3>

<ul>
<li><p>__construct()<br/>
注入了一个依赖\(definitionSource,就是上面说到的\)definition数组, 框架需要的基础对象;<br/>
初始化了ResolverDispatcher对象,主要用来执行实例化;<br/>
初始化了ProxyFactory对象,代理工厂;</p></li>
<li><p>make() 常用核心方法<br/>
Container的本质是通过一个数组$resolvedEntries来管理已经实例化的对象.实例化的对象,通过set()方法保存在容器的这个变量内,下次获取的时候直接可以返回;所以容器管理的对象都可以看做是单例实现的.  </p>
<p>而make()方法不太一样,每次make后会返回一个新的对象,从而使Container变成了一个类工厂;make一个对象,是通过调用$this-&gt;ResolverDispatcher实现的;一个Definition如果可以自己resolve(实现了SelfResolvingDefinitionInterface接口),就调用Definition的resolve方法自己处理就好了;否则就根据是不是工厂类来决定,是通过ObjectResolver还是FactoryResolver来resolve;<br/>
resolve的核心就是createInstance,说白了就是new一个类,然后把依赖在注入进去:</p>
<pre><code class="language-php">$object = new $className(...$args);
$this-&gt;injectProperties($object, $definition);
</code></pre>
<p>有兴趣可以自己在深入看一下.</p></li>
</ul>

<h3 id="toc_4"><a name="初始化应用">初始化应用Application</a></h3>

<p>通过容器拿到Application的工厂.\Hyperf\Contract\ApplicationInterface对应的实现为\Hyperf\Framework\ApplicationFactory</p>

<ul>
<li><p><a name="ApplicationFactory">ApplicationFactory</a><br/>
工厂类,只有__invoke(), 环境初始化/注入依赖,最后得到$application对象<br/><br/>
如果存在EventDispatcher (此处默认实现为Hyperf\Event\EventDispatcher)则发出框架第一个Event:Hyperf\Framework\Event\BootApplication,可以监听此Event在框架启动前做一些操作.  </p>
<p>通过$config和AnnotationCollector,拿到配置定义的和注解定义的Commands,就是hyperf.php支持的所有Commands,传给Application进行注册.</p>
<p>这个Application直接用的Symfony\Component\Console\Application,一个在CLI环境使用的Application;区别于Laravel继承的Symfony的Application是在WEB环境用的;因为Hyperf+swoole只有CLI环境,不需要FPM,所以不用.</p>
<p>new Application后,设置了事件的Dispatcher分发器,这个SymfonyEventDispatcher实际上是Hyperf\Framework\SymfonyEventDispatcher,把注入的Hyperf\Event\EventDispatcher包装一下以符合SymfonyDispatcherInterface才能传给Symfony的Application.</p></li>
<li><p><a name="Application">Application</a><br/>
看一下最终的Application实现:Symfony\Component\Console\Application</p>
<ul>
<li><p>__construct()<br/>
很简单 初始化一些参数;<br/>
Terminal指的就是真正的终端,获取一些终端窗口的属性,长宽,环境变量等等</p></li>
<li><p>run()<br/>
在hyperf.php中拿到application后,执行的run方法就是这个方法;<br/>
先进行一系列的初始化: 设置Terminal的宽高属性;设置输入&amp;输出的对象;设置报错的回调ExceptionHandler;<br/>
在try...catch中,调用$this-&gt;doRun()继续执行;</p></li>
<li><p>doRun()<br/>
如果参数中有类似-V --help的参数,直接处理返回,不再继续;<br/>
如果没传参数,则给一个默认的命令&quot;command&quot;;<br/>
然后调用$this-&gt;find()查找这个命令,找到后,得到一个 Command对象, 继续调用doRunCommand()真正执行命令;<br/>
Symfony\Component\Console\Command类值得一看,每个命令都是一个Command对象,但这个对象却不是抽象的;execute()方法的注释写的很明白:你不仅可以继承这个类实现一个Command,也可以直接用这个类的实体对象;这种情况下,通过setCode()方法设置一个回调,通过\Closure::bind()方法把这个对象(也就是this)本身绑定给回调函数,可以做到&quot;在运行时给对象增加方法&quot;的效果;具体可以看一下官方文档.</p></li>
<li><p>doRunCommand()<br/>
真正执行Command;<br/>
如果Application没设置Event的Dispatcher(默认为Hyperf/Event/Dispatcher 参看前面),直接执行Command-&gt;run(),否则先发出一个ConsoleCommandEvent事件,事件执行完再执行Command</p></li>
</ul></li>
</ul>

<h3 id="toc_5"><a name="结尾">结尾</a></h3>

<p>至此,框架的初始化就基本上完成了.<br/>
下一章继续讲,在执行了&quot;start&quot;命令后,框架都做了哪些动作.</p>

<p>现代化的框架,通过容器来管理类和对象,框架生命周期的各个阶段都有事件Event,可以方便而无入侵的改变框架本身,开放而灵活.<br/>
Hyperf引入的AOP与注解,增加了容器的复杂性,同时也给开发者带来了更多便利.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二维数组排序 array multisort]]></title>
    <link href="blog.v2cb.com/15756185241314.html"/>
    <updated>2019-12-06T15:48:44+08:00</updated>
    <id>blog.v2cb.com/15756185241314.html</id>
    <content type="html"><![CDATA[
<p>一个这样的二维数组</p>

<pre><code class="language-text">array(6) {
  [0]=&gt;
  array(4) {
    [&quot;customer_name&quot;]=&gt;
    string(6) &quot;小李&quot;
    [&quot;money&quot;]=&gt;
    int(12)
    [&quot;distance&quot;]=&gt;
    int(2)
    [&quot;address&quot;]=&gt;
    string(13) &quot;长安街C坊&quot;
  }
  [1]=&gt;
  array(4) {
    [&quot;customer_name&quot;]=&gt;
    string(6) &quot;王晓&quot;
    [&quot;money&quot;]=&gt;
    int(30)
    [&quot;distance&quot;]=&gt;
    int(10)
    [&quot;address&quot;]=&gt;
    string(14) &quot;北大街30号&quot;
  }
}
</code></pre>

<p>想根据distance排序,则先构建一个1维数组<br/>
key是原数组的key,值是distance的值.这样根据值来排序,就得到了排序过的key.</p>

<p>在根据这个key,就可以对原来数组的key进行重新排序了.</p>

<p>这个过程就是array_multisort的过程,第一个数组是构造的新的1维数组,第二个数组是待排序的数组.</p>

<h2 id="toc_0">通过usort</h2>

<p>usort可以传一个匿名function(\(a,\)b)<br/>
返回值,a&gt;b则返回大于0的值 a&lt;b返回小于0的值</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP中的闭包理解]]></title>
    <link href="blog.v2cb.com/15931630289738.html"/>
    <updated>2020-06-26T17:17:08+08:00</updated>
    <id>blog.v2cb.com/15931630289738.html</id>
    <content type="html"><![CDATA[
<p>没有名字的函数叫&quot;匿名函数&quot;,这个很好理解.但单纯的匿名函数不是闭包,只有当匿名函数绑定了外部变量的时候,此时才形成了一个&quot;闭包&quot;.</p>

<p>在JS中,闭包被广泛使用,一方面由于JS的垃圾回收机制,一方面由于JS的作用域比较简单,没有namespace这些&quot;高级&quot;的用法.JS创建闭包的时候,相对于PHP,会隐式地绑定外部变量,所以很多时候都没有意识到用到了闭包.</p>

<p>在PHP中,创建一个匿名函数,通过use引用外部变量,此时就创建了一个&quot;闭包&quot;.</p>

<p>对于闭包而言,引入外部变量可以通过函数传参,也可以通过use来绑定外部变量,从而在匿名函数内可以使用.区别在于,对于传参而言,函数在被调用(called)的时候才会绑定参数变量.<br/>
而闭包是在函数定义的时候,就&quot;绑定&quot;了外部的变量.</p>

<p>闭包相当于一个独立的namespace空间.闭包内部定义的变量,外部是不可访问的.外部的变量,需要通过use才能被使用.这样形成了一个局部的&quot;作用域&quot;,避免了变量污染问题.</p>

<p>use的作用可以理解为&quot;早期绑定(early binding)&quot;,在函数定义的时候把外部变量拷贝到闭包里面.除非use了一个引用,否则闭包内对绑定的参数的修改,不会影响到外部.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rainyluo's Blog]]></title>
    <link href="blog.v2cb.com/15923063081658.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063081658.html</id>
    <content type="html"><![CDATA[
<p>90后,帝都.  </p>

<p>PHP研发工程师</p>

<p>关注性能优化.喜欢研究产品,关注商业.</p>

<p>喜欢思考,阅读,旅行.</p>

<p>喜欢业余捣鼓一些Side Project.</p>

<p>目前在一家互联网文学相关公司任职.</p>

<p>Git    <a href="https://github.com/xiaotianhu">https://github.com/xiaotianhu</a><br/>
Email  xiaotianhu@qq dot com<br/>
Follow me @rainyluo(Sina)</p>

<p><img src="media/15923063081658/15927253042599.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何变得平庸]]></title>
    <link href="blog.v2cb.com/15923063082122.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063082122.html</id>
    <content type="html"><![CDATA[
<p>Tags:  随感<br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>最近这几个月,面了一些公司.总的来说,面试就如同上学时候的期中考试,不为了跳槽换工作,是为了检测一下自己,也是为了画画重点,看看市场需求.这不就获得了一些感受,记录一下.</p>

<p>对平庸和伟大的认识更深刻了.平庸的反义词也不一定就是&quot;伟大&quot;,也可以是&quot;出色的&quot;或者&quot;特别厉害&quot;,姑且称之为&quot;伟大&quot;吧.比如在现阶段而言,对于我司这样的创业公司,和我们提供的产品,就很难说是伟大.人们说iPhone伟大,最开始是因为它的创新性带来的划时代变革, 那么如今的iPhone伟大更多的是因为在某个方面它依然是最出色的,比如稳定性,比如触摸的手感.而我们公司的产品,它提供了很多功能,别的同类App基本上也都有,但是我们没有什么方面做的特别好,对于核心功能也是一样.能用,但是没有特别出色的点.</p>

<p>前几天听东吴同学会也说起这点,乔布斯的禅与哲学,很核心的一点就在于&quot;什么不做&quot;.如果要做,就一定要做到最好,这样的匠心精神,取舍的哲学,让iPhone成为我心中最伟大的手机,让日本这样的小国有今天的实力,这也是我们今天整个社会强调的&quot;认真&quot;的态度与精神.说到底,就是死磕一个事儿,做到极致.</p>

<p>做公司如此,做产品如此,做人也是一样.而我就是那个&quot;懂得了很多道理,却依然过不好这一生&quot;的那个人.</p>

<p>究其原因,道理都是对的,人人都知道.关键在于怎么执行,如何坚持.没有这两点,再牛逼的道理也是空谈,这就是人与人之间的差距比人与狗之间的差距还大的原因.反观我这几年的进步缓慢,其实也不能说是&quot;缓慢&quot;,而是方向性问题.从&quot;术&quot;的方面来说,新技术层出不穷,从大数据到AI,从机器学习到比特币,啥玩意出来了都觉得能发财,不想被时代落下,也不管这玩意的本质是啥就开始研究,看了几天入个门浪潮过了,新一波又来了.所以&quot;求求你们别更了,学不动了&quot;这句话才能引起这么多共鸣.从&quot;业&quot;的方面来说,13年那会儿创业浪潮,觉得在大公司混着没意思还是得去创业公司发大财,去了发现老板根本没打算带你发财.觉得自己是个人才还是得自己干,研究半天都不知道从哪儿开始,要啥没啥.创业的浪潮随着资本冷却也凉了,眼看自己不是这块料 ,大公司也回不去了,人也看不上你了.浑浑噩噩走到现在,眼见在猎豹的上市发财了,去小米的上市发财了,连炒比特币的好多人都发财了,觉得自己生不逢时啊,早生两年这好事儿不是我也能赶上.</p>

<p>究其原因,这个社会的问题,我的问题,不是选择太少,而是选择太多.就像平庸的公司与平庸的产品,什么都想做,什么都做不好.眼看别人做这个火了,我也要整一个,人的精力是有限的,哪怕一家公司一个产品,其实核心决策也就在于那么一两个人,都是有限的.然后这个时代因为选择的极大丰富,人们更多的是需要某一方面&quot;伟大&quot;的东西,而不是一个&quot;啥都能干,都一般&quot;的东西.为什么会这样?短视,功利,甚至&quot;实用主义&quot;,&quot;够用,能用就好&quot;的想法,都在让我,公司,产品,变得平庸.</p>

<p>取舍是需要大智慧的.就像地上有一张50元和一张100元,你怎么选?大部分人会觉得我可以两张都捡起来,这是&quot;生意&quot;;可现实的潜规则往往是,捡了一张另一张就没了,甚至更可能是你在中间抓了一把,却什么都没抓住,一分钱也没捞到.然后呢,后悔,迷茫,惋惜,当初我应该捡起那个50的,也不错啊... <br/>
  所以做出正确选择的前提是对自己有清晰,客观的认识.又有多少人能做到这一点呢?哪个人照照镜子不觉得自己没那么丑,或者至少还是&quot;有一点可取之处&quot;的?</p>

<p>诶,平庸的人 ...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocopods重装解决framework not found Pods/no such module]]></title>
    <link href="blog.v2cb.com/15923063082414.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063082414.html</id>
    <content type="html"><![CDATA[
<p>刚开始学习Swift ios开发。<br/>
使用cocopods安装SnapKit, Xcode版本10.1 Swift4.2,按照Snapkit官网文档，修改Podfile之后Podinstall，中途一顿操作，结果不能用。  </p>

<p>发现我原来是忘记在需要的地方import SnapKit了。  </p>

<p>加上这行后，Xcode报 no such module。一顿折腾无果，找到一个解决方案：<a href="https://stackoverflow.com/questions/29865899/ld-framework-not-found-pods">https://stackoverflow.com/questions/29865899/ld-framework-not-found-pods</a></p>

<p>重新初始化pods的好方法：</p>

<pre><code class="language-text">Xcode 9, 10, 11

install https://github.com/CocoaPods/cocoapods-deintegrate

pod deintegrate
then

pod install
</code></pre>

<p>完美解决，import SnapKit就可以了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[reactPHP + lumen性能简测]]></title>
    <link href="blog.v2cb.com/15923063083212.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063083212.html</id>
    <content type="html"><![CDATA[
<p>Tags:  react PHP lumen<br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>工作需要,新项目用Lumen框架来做.因为后端API,用Laravel感觉更大了,用Lumen还能轻量一点.接口写的差不多了,就研究捣鼓一下性能.Lumen本身的性能还是很捉鸡,不光Composer载入一大坨依赖,自己的框架就很复杂,虽然容器的思路真的很棒,对于工程而言是非常好的设计,但是性能比简单框架还是差一些的.</p>

<p>开始想着上Swoole,有第三方的lumen-swoole的包:</p>

<pre><code class="language-text">composer require encore/lumen-swoole 5.3.x-dev
</code></pre>

<p>但是我swoole版本太高了,懒得重新编译swoole了,把这个项目直接clone到lumen项目的packages文件夹(自己建一个),然后修改composer.json</p>

<pre><code class="language-text">&quot;repositories&quot;: [
    {
        &quot;type&quot;: &quot;path&quot;,
        &quot;url&quot;: &quot;packages/lumen-swoole&quot;
    }
]

手动修改一下lumen-swoole的swoole依赖版本号,然后 
composer require &quot;encore/lumen-swoole:*@dev&quot;

然后就可以用本地修改过的lumen-swoole 来安装了.
</code></pre>

<p>运行会报错,发现目录是ln过去的,有点问题<br/><br/>
直接把 packages/lumen-swoole 拷贝到vendor/encore/lumen-swoole下<br/><br/>
运行:<br/><br/>
./vendor/encore/lumen-swoole/bin/lumen-swoole -s /home/luo/git/lumen_api/bootstrap/app.php --worker_num 50<br/><br/>
就启动成功了~</p>

<p>总觉得swoole这种扩展的方式略麻烦,给运维和部署都带来一点麻烦.想起来之前看过的ReactPHP,寻寻觅觅找到了PHP-PM这个项目:</p>

<pre><code class="language-text">https://github.com/php-pm/php-pm 
</code></pre>

<p>这个就是给ReactPHP做了个多进程的管理器,跟PHP-FPM的感觉差不多.然而这货支持Laravel却不能用Lumen5.2,真是坑爹.折腾了一天多那个HttpKernel也没能给Lumen跑起来,各种问题;转而一想直接用ReactPHP试试吧,正好后续我还需要用websocket做点事儿;</p>

<pre><code class="language-text">https://github.com/reactphp/react 
</code></pre>

<p>这货的介绍很简单:Nuclear Reactor written in PHP. <a href="http://reactphp.org">http://reactphp.org</a></p>

<p>本质上就是拿PHP写的一个异步非阻塞框架,如果有Libevent扩展就会用Libevent相关函数来做,没有的话他们拿PHP写了个事件循环,用stream_select来调度事件,性能会比用libevent/libev差一些了,不过Lumen的性能瓶颈并不在此;主要还是频繁初始化框架消耗的资源太多;</p>

<p>安装比较简单:</p>

<pre><code class="language-text">composer require react/react 
</code></pre>

<p>在lumen/public下新建个server.php作为启动服务器的入口,代码如下</p>

<pre><code class="language-text">&lt;code&gt;
&lt;?php
require &#39;../vendor/autoload.php&#39;;

function processUri($query) {
    if(empty($query[&#39;c&#39;]) || empty($query[&#39;a&#39;])) return false;
    foreach($query as $key=&gt;$val) {
        if($key != &#39;a&#39; &amp;&amp; $key != &#39;c&#39;) $_GET[$key] = $val;
    }
    return &quot;/{$query[&#39;c&#39;]}/{$query[&#39;a&#39;]}&quot;;
}

$lumenApp = require __DIR__.&#39;/../bootstrap/app.php&#39;;
$app = function ($request, $response) use ($lumenApp){
    $_SERVER[&quot;ENV_STATUS&quot;]     = &#39;dev&#39;;
    $_SERVER[&quot;REQUEST_URI&quot;]    = processUri($request-&gt;getQuery());
    if(empty($_SERVER[&quot;REQUEST_URI&quot;])) return false;
    $_SERVER[&quot;REQUEST_METHOD&quot;] = $request-&gt;getMethod();
    $lumenApp-&gt;instance(&#39;StreamResponse&#39;, $response);
    $lumenApp-&gt;run();
};


$loop        = React\EventLoop\Factory::create();
$socket      = new React\Socket\Server($loop);
$http        = new React\Http\Server($socket);

$http-&gt;on(&#39;request&#39;, $app);

$socket-&gt;listen(1338, &quot;0.0.0.0&quot;);
$loop-&gt;run();
&lt;/code&gt;
</code></pre>

<p>为了跑起来简单一写,没有优化;因为没有nginx所以rewrite也没有的,访问的时候需要用127.0.0.1:1338/index.php?c=controller&amp;a=function&amp;a=b这样的格式来访问;返回的话,可以写一个Middleware来拦截Response返回:</p>

<pre><code class="language-text">public function handle($request, Closure $next)
{
    $response = $next($request);
    if (!($response instanceof Response)) {
        $response = response($response);
    }
    $resContent = $response-&gt;getContent();
    //reactPHP response
    $r = app(&#39;StreamResponse&#39;);
    $r-&gt;writeHead(200, [&#39;Content-Type&#39; =&gt; &#39;application/json;charset=UTF-8&#39;]);
    $r-&gt;write($resContent);
    $r-&gt;end();
}
</code></pre>

<p>如果是接口有统一的返回方法也可以直接在返回方法中写;对于静态文件,可以参考这个库:</p>

<pre><code class="language-text">https://github.com/phly/react2psr7
</code></pre>

<p>我是直接拿来用了,没有按照示例的那么啰嗦:</p>

<pre><code class="language-text">Server.php

....

use React2Psr7\StaticFiles;
$staticFiles = new React2Psr7\StaticFiles(dirname(__DIR__).&quot;/public&quot;);

$loop        = React\EventLoop\Factory::create();
$socket      = new React\Socket\Server($loop);
$http        = new React\Http\Server($socket);

$handler = function($request, $response) use ($lumenApp, $staticFiles){
    return $staticFiles($request, $response, $lumenApp);
};
$http-&gt;on(&#39;request&#39;, $handler);

....

</code></pre>

<p>捣鼓差不多了,直接php server.php启动,开始测试.上几个测试图吧</p>

<p><img src="media/blog/swoole50worker.png" alt=""/><br/>
swoole 50个worker的效果,性能确实牛逼</p>

<p><img src="media/blog/swoole1worker.png" alt=""/><br/>
swoole 1个worker,为了跟reactPHP对比</p>

<p><img src="media/blog/reactphp.png" alt=""/><br/>
reactPHP的性能;可以看出来,单核心性能跟swoole不相上下,但是稳定性还是有点略差,有一定的timeout和崩溃等等情况的概率,所以后面有空捣鼓一下phppm,就跟swoole一样有进程管理机制,应该就好多了.BTW,变量就要记得释放,要不然泄露起来也真是麻烦啊,很难找嘞</p>

<p>这个接口,用NGINX+PHP-FPM 50个进程,RPS大概是60;没法比啊没法比...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pts导入bts2.0教程]]></title>
    <link href="blog.v2cb.com/15923063083603.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063083603.html</id>
    <content type="html"><![CDATA[
<p>Tags:  bts<br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>随着bts价格一路走高,很多人都开始研究起bts了.当年bts通过pts众筹的时候,估计很多人都挖过pts,然后可以看到很多人在pts导入bts2.0的时候都失败了.我也是其中之一,经过N天的尝试-放弃-尝试,终于成功了.把一些经验和关键点分享一下.  </p>

<p>首先感谢HIPDA论坛的lcjin哥们.在我放弃的时候,指点了我半天.最重要的是叫我不要放弃,让我给开发团队写信,给了我信心.坚持找了半天资料,最终成功,功夫不负啊!  </p>

<p>基本的套路不多讲了,pts.dat备份文件导入到053版本bts钱包,然后在导入093c版本后导出json备份(注意用console),然后导入2.0版本的钱包.网上的教程  <a href="http://btsabc.org/download/%E5%8E%9F%E5%A7%8B%E8%82%A1%EF%BC%88PTS%E3%80%81AGS%EF%BC%89%E5%85%91%E6%8D%A2BTS%E3%80%81PLS%E3%80%81MUSE%20%E6%95%99%E7%A8%8B.pdf(PTS%E3%80%81AGS">http://btsabc.org/download/%E5%8E%9F%E5%A7%8B%E8%82%A1%EF%BC%88PTS%E3%80%81AGS%EF%BC%89%E5%85%91%E6%8D%A2BTS%E3%80%81PLS%E3%80%81MUSE%20%E6%95%99%E7%A8%8B.pdf(PTS、AGS</a> 兑换BTS、PLS、MUSE - 比特股中文网) 写的还是很清楚的.  </p>

<p>最关键的问题,在于导入2.0后如何声明的问题.按照教程,把093c的json导入到2.0版本bts钱包,然后在钱包里查询来自1.0的余额,显示没有未领取.各种尝试都不行.<br/>
<img src="media/blog/no_blances.jpg" alt=""/></p>

<p>后来读到一篇帖子,核心问题讲的很明白了,地址如下</p>

<pre><code class="language-text">https://bitsharestalk.org/index.php/topic,24124.msg305890.html#msg305890
</code></pre>

<p>抄录一下解决的核心思路</p>

<pre><code class="language-text">Sorry for late reply. I am not great at elaborating stuffs. 

When FLuxer helped me, I learned a few things that i have not tried before.  1st, you need to make a wallet account. 2nd, make a backup after importing the keys to your wallet account (make sure to add &quot;dot&quot; BIN on the file name.) I will be making a video and will post it here. 

If, however, you only have a wallet.dat file, you will need to
1. install BitShares 0.9.3
2. create an account in the BitShares 0.9.3 wallet 
3. import the wallet.dat file into your account (Import your Bitcoin wallet.dat)
     https://drive.google.com/open?id=0B7288nKEgxRJRXdNX0lmeTljQTg

4. Then Export your keys: 
     Export via the console
navigate to the console: Account List -&gt; Advanced Settings -&gt; Console
type: wallet_export_keys [full path to the file]/[file name].json e.g. on Windows: wallet_export_keys C:\Users\[your user name]\Desktop\keys.json e.g. on Mac: wallet_export_keys /Users/[your user name]/Desktop/keys.json e.g. on Linux: wallet_export_keys /home/[your user name]/Desktop/keys.json
Please replace [your user name] with your Windows account name.
and hit Enter 
     http://docs.bitshares.eu/_images/export-wallet-console.png

5. Now Proceed to Bitshares 2.0. Create a wallet account model. 

6. Go to settings and Restore/Import: https://drive.google.com/open?id=0B7288nKEgxRJNVBhUzUyUTFETDg

7. Go to Wallet and Click Lookup Balance: https://drive.google.com/open?id=0B7288nKEgxRJU0ZETHZXc20xeTg

8. Create Backup (Make sure you add .BIN when saving the file): https://drive.google.com/open?id=0B7288nKEgxRJTWpiOVRSb3NjeDg
     See the difference: https://drive.google.com/open?id=0B7288nKEgxRJMTVqd3V6NmRnREU

9.  You may need to make a new account or change your wallet profile, but the next step is to go to restore/import and import the BIN file. 
https://drive.google.com/open?id=0B7288nKEgxRJMkd4QUNVb05IODg

10 Repeat Step 7. you should be able to see your keys. Then Claim it. 

11. Donate to luther-10 if you find this helpful. If you want me to make a video, someone should lend  me their unclaim private keys and i will make it into video to help everyone.  
</code></pre>

<p>总结一下2.0操作套路</p>

<pre><code class="language-text">新建本地钱包,导入093c的备份,此时没有unclaimed blances
备份本地钱包(bin格式)
新建一个新的本地钱包账户
在新建的钱包里面导入老的bin备份
此时lookup for unclaimed blance就应该有了
</code></pre>

<p><img src="media/blog/lookupblances.jpg" alt=""/></p>

<pre><code class="language-text">我是用web的在线钱包操作成功的
https://bitshares.openledger.info/
</code></pre>

<p>so,good luck everyone</p>

<p>有疑问的可以email: <a href="mailto:xiaotianhu@qq.com">xiaotianhu@qq.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gopush代码分析-comet模块]]></title>
    <link href="blog.v2cb.com/15923063083769.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063083769.html</id>
    <content type="html"><![CDATA[
<p>Tags:  go 推送 <br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>=<mark>Comet模块</mark>=</p>

<blockquote>
<p>负责SOCKET连接处理,支持TCP SOCKET与WEBSOCKET两种协议,数据传输采用REDIS的序列化协议</p>
</blockquote>

<p>main启动后,初始化如下<br/>
InitConfig()<br/>
perf.Init(Conf.PprofBind)<br/>
NewChannelList()<br/>
StartStats()<br/>
StartRPC()<br/>
StartComet()<br/>
InitZK()<br/>
InitSignal()</p>

<p>其中,NewChannelList()根据 Conf.ChannelBucket指定的数量,初始化一定量的 &amp;ChannelBucket对象,并把这些bucket加入到&amp;ChannelList中.整个ChannelList的结构很简单:</p>

<pre><code class="language-text">type ChannelList struct {
    Channels []*ChannelBucket
}
</code></pre>

<p>Bucket可以理解为一个池,初始化好这个池后,每一个新进来的链接,都会根据MruMruHash算法,把SeqChannel平均分配加入到Bucket这个池子中,这个后面会讲到.</p>

<p>先从主体开始说起吧,StartComet()当然是主要的了,根据配置里的proto协议,分别或者全部启动TCP与WEBSOCKET监听,此处拿TCP监听为例.StartTCP()后,根据Conf.TCPBind的配置,启动多个TCP监听routine:</p>

<pre><code class="language-text">go tcpListen(bind)
</code></pre>

<p>开始Listen后,在for循环中不停的开始Accept,并且设置了TCP相应的参数,每个新进入的连接,开启一个新的routine处理:</p>

<pre><code class="language-text">for{
    conn.SetKeepAlive(Conf.TCPKeepalive)
    conn.SetReadBuffer(Conf.RcvbufSize)
    conn.SetWriteBuffer(Conf.SndbufSize)
    conn.SetReadDeadline(time.Now().Add(fitstPacketTimedoutSec))
    go handleTCPConn(conn, rc)
}
</code></pre>

<p>进入处理SOCKET数据的阶段了,BufIoReader读取SOCKET的数据,解析参数 </p>

<pre><code class="language-text">parseCmd(rd)
</code></pre>

<p>值得一说的是GoPush采用的(REDIS的协议)[<a href="http://redis.io/topics/protocol%5D,%E8%BF%99%E7%AF%87%E8%AF%B4%E6%98%8E%E5%86%99%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86%E4%BA%86.%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCJSON%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE,%E6%94%AF%E6%8C%81%E6%95%B0%E7%BB%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%95%B0%E5%AD%97/%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%A0%E9%80%92,%E6%AF%94%E8%BE%83%E5%8F%8B%E5%A5%BD%E6%98%8E%E6%96%87%E5%8F%AF%E8%AF%BB,%E5%B9%B6%E4%B8%94%E8%A7%A3%E6%9E%90%E6%95%88%E7%8E%87%E9%AB%98,%E5%A0%AA%E6%AF%942%E8%BF%9B%E5%88%B6%7E">http://redis.io/topics/protocol],这篇说明写的很详细了.就是一个类似JSON的序列化协议,支持数组/字符串/数字/错误信息/几种简单数据结构的传递,比较友好明文可读,并且解析效率高,堪比2进制~</a></p>

<p>args[0]代表命令,默认必须是sub,否则报错.这块的逻辑跟Redis的PUB/SUB模型比较类似,都是Client订阅某个Channel,然后等待消息推送过来.<br/>
接下来对args中的几个参数,key/heartbeat/token/version进行判断,然后新建一个用于通讯的channel:</p>

<pre><code class="language-text">UserChannel.Get(key, true)
</code></pre>

<p>这个UserChannel.Get()方法又做了一些事 比较复杂.之前在初始化的时候,新建了一个ChannelList,里面保存了一组初始化好的Bucket,用来做Channel的池.Get方法,先验证一下Client需要Sub的Key是不是属于这个Comet节点的:</p>

<pre><code class="language-text">node := CometRing.Hash(key)
if Conf.ZookeeperCometNode != node {
    log.Warn(&quot;user_key:\&quot;%s\&quot; node:%s not match this node:%s&quot;, key, node, Conf.ZookeeperCometNode)
    return ErrChannelKey
}

</code></pre>

<p>CometRing.Hash 就是采用ketama(ketama:libketama-style consistent hashing in Go)的一致性哈希算法,<a href="https://github.com/mncaudill/ketama">ketama项目地址</a><br/>
验证通过后,从ChannelList的Bucket中,获取这个Key对应的SeqChannel,如果没有则新建</p>

<pre><code class="language-text">b := l.Bucket(key)
if c, ok := b.Data[key]; !ok {
    if !Conf.Auth &amp;&amp; newOne {
        c = NewSeqChannel()
        b.Data[key] = c
        ...
        return c, nil
    } else {
      ...       
    }
} else {
    ...
    return c, nil
}
</code></pre>

<p>SeqChannel是外部与Client沟通的通道,比如从Web发过来的消息,通过RPC传给Comet模块,在通过SeqChannel发给Client,另外还有Token验证的功能,比较简单一看就好了</p>

<p>接下来就是在这个routine中持续监听Socket数据流并发送心跳了,如果产生错误就break并删除SeqChannel.</p>

<pre><code class="language-text">for {
    conn.SetReadDeadline(time.Now().Add(time.Second * time.Duration(heartbeat)))
    conn.Read(reply)    
    if string(reply) == Heartbeat {
        ...
        conn.Write(HeartbeatReply) //服务器发来心跳,并写一个心跳回去
    }
    end = time.Now().UnixNano() //更新SOCKET超时时间
}
</code></pre>

<blockquote>
<p>到此,主要的Socket监听/通讯/心跳就完成了.</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome Extension扩展开发之复制粘贴]]></title>
    <link href="blog.v2cb.com/15923063083833.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063083833.html</id>
    <content type="html"><![CDATA[
<p>Tags:  chrome extension 粘贴<br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>最近在研究Chrome Extension扩展开发.想实现一个功能,选中文本后写入到插件弹层的div中.<br/><br/>
一开始想的方案,用Selection来实现.钻研了好几天的Selection,总是有莫名其妙的问题,在某些页面选中文本后Selection对象里面无法获取到文本内容,感觉跟过于复杂的DOM结构有点关系.灵机一动,用复制粘贴不就解决了嘛,鼠标选中文本后自动复制,然后在弹出的div层中把文本粘贴回来就行了,如此简单的方案 岂不美滋滋.说干就干</p>

<p>翻了翻方案,读写clipboard两条命令搞定:</p>

<pre><code class="language-text">document.execcommand(&#39;copy&#39;)
document.execcommand(&#39;paste&#39;)
</code></pre>

<p>然后在onmouseup里面调用一下copy,复制就搞定了,美滋滋<br/><br/>
然而,paste却死活不行.调用document.execcommand(&#39;paste&#39;),返回值总是false,死活不行.查了半天,Chrome因为安全问题禁用了读取剪切板内容...这不坑爹了</p>

<p>不信邪 一顿操作猛如虎,找到两个solution</p>

<pre><code class="language-text">https://stackoverflow.com/questions/7144702/the-proper-use-of-execcommandpaste-in-a-chrome-extension

https://gist.github.com/srsudar/e9a41228f06f32f272a2
</code></pre>

<p>stackoverflow讲的不是很明白,但是信息是明确的:Chrome的Extension里面是可以调用这个方法的,这个路子肯定是没问题的.大方向没问题,就开始折腾.</p>

<p>开始在Content Script(就是注入到页面的js)各种折腾,各种失败.继续搜了半天,只有在background.js里面才有权限.</p>

<p>那么,思路基本上是:必须在background.js里面调用paste拿到剪贴板内容,然后传给页面里的JS.<br/>
开始在页面js里面调用chrome.extension.getBackgroundPage(),死活也不行.翻官方手册,貌似可以用传Message的方式进行通讯.一顿尝试,最终成功,必须记录一下了.</p>

<p>background.js:</p>

<pre><code class="language-text">chrome.runtime.onMessage.addListener(
    function(request, sender, sendResponse){
        var result = &#39;&#39;;
        var sandbox = document.getElementById(&#39;sandbox&#39;);
        sandbox.value = &#39;&#39;;
        sandbox.select();
        if (document.execCommand(&#39;paste&#39;)) {
            result = sandbox.value;
        }
        sandbox.value = &#39;&#39;;
        sendResponse({clipboard: result});
    }
)
</code></pre>

<p>background.html</p>

<pre><code class="language-text">&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;script src=&quot;background.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;textarea id=&quot;sandbox&quot;&gt;&lt;/textarea&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>

<p>mainfest.json  </p>

<pre><code class="language-text">&quot;background&quot;: {
    &quot;persistent&quot;: true,
    &quot;page&quot;: &quot;background.html&quot;
  },
 ...
 
权限我加入了&quot;clipboardRead&quot;, &quot;clipboardWrite&quot;,&quot;background&quot;这几个,
web_accessible_resources加入&quot;background.html&quot;,&quot;background.js&quot; 懒得去测每个值的影响了,反正都加上了
 
</code></pre>

<p>在需要获取剪切板内容的方法里发消息:</p>

<pre><code class="language-text">chrome.runtime.sendMessage({}, function (response){
     console.log(response);
});
           
</code></pre>

<p>response中就可以获取到剪切板的内容了,搞定!</p>

<p>PS:<br/>
调试background.html的时候,这里面引入的js的debug信息和console信息,是不会在普通的tab页面中显示的.导致我摸黑调试了半天,浪费了很多时间.background相关的调试信息,需要在chrome://extensions/里面打开 develop mode,然后在插件下面点击&quot;Inspect views: background.html&quot;在弹出的inspector里面就可以看到debug信息了.有了信息在debug就方便多了.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iowait详解]]></title>
    <link href="blog.v2cb.com/15923063084125.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063084125.html</id>
    <content type="html"><![CDATA[
<p>Tags:  iowait linux <br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<h1 id="toc_0">iowait详解</h1>

<blockquote>
<p>翻译自<a href="https://blog.pregos.info/wp-content/uploads/2010/09/iowait.txt">https://blog.pregos.info/wp-content/uploads/2010/09/iowait.txt</a><br/>
缘起:<a href="https://serverfault.com/questions/12679/can-anyone-explain-precisely-what-iowait-is">https://serverfault.com/questions/12679/can-anyone-explain-precisely-what-iowait-is</a></p>
</blockquote>

<p>So,到底什么是 &quot;iowait&quot;?</p>

<p>一句话总结一下:iowait是CPU处于idle空闲状态,并且至少有1个I/O处在处理中状态的时间百分比.</p>

<p>每个CPU可能处在以下四种状态中的一种:user,sys,idel,iowait;性能测试工具比如vmstat,iostat,sar,都可以把这四种状态以百分比的形式显示出来.sar工具可以通过-P参数显示每个CPU的基础信息,但是其他大部分工具都是显示所有CPU核心的平均值.这四种状态的百分比相加为100%.</p>

<p>这些工具显示的统计信息,是通过内核周期性更新统计出来的.(对于AIX,CPU统计更新周期为每个时钟中断,10毫秒一次).当CPU发生时钟中断,内核会检查CPU是不是处于idle状态.如果不是idle状态,那么内核会判断正在执行的命令是用户态还是内核态,如果是用户态则吧&#39;user&#39;加一,如果是内核态则把&#39;sys&#39;加一.</p>

<p>如果cpu处在idle状态,内核会判断是不是有IO读写正在进行,如果至少有一个IO正在执行,不管是本地磁盘读写还是远程磁盘读写(比如mount的NFS磁盘);如果有,那么&#39;iowait&#39;计数器就会加一.如果没有IO正在进行,&#39;idle&#39;计数器就加一.</p>

<p>当运行性能测试工具,比如vmstat的时候,它读取的就是这四个状态的计数器,然后根据用户指定的时间睡眠几秒,然后在读取一次.然后vmstat会根据两次取值的绝对值,计算出这一段取样时间的变化值.vmstat知道每次时钟滴答都会改变计数器的值,它就可以算出每次时钟滴答内计数器的变化量.举个栗子,如果执行&quot;vmstat 2&quot;,vmstat就会每2秒钟对计数器进行一次取样.由于每次时钟循环时间在10ms,所以每秒有100次循环,2s就有200次时钟循环.每个计数器的差值除以循环周期的总统计次数,乘以100就得到了周期内的百分比.</p>

<p>iowait在某些情况下,可以作为衡量系统吞吐能力的一个指标,但是在另外一些情况下,这个数值可能是毫无意义的.<br/>
有一些例子来帮助解释一下这个情况.第一个例子,iowait是导致性能原因的直接因素:</p>

<h3 id="toc_1">Example 1:</h3>

<p>假设有一个程序,需要执行一组包含多个任务的事务.每个事务执行的过程中,需要执行10ms计算任务,然后把结果以同步的方式写入磁盘.由于要写入的文件是以同步方式打开的,所以只有当写入的I/O操作全部完成后,写入调用才会返回.假设磁盘系统没有cache缓存,并且每次写入的I/O操作需要20ms.在这种情况下,每次事务操作需要30ms.在1S内(1000ms)这个程序可以完成33次事务(33tps).如果这个程序是在单核心系统(1CPU)上运行的唯一的程序,那么CPU的使用率会是1/3处在忙(busy)状态,剩下的时间等待I/O - 所以是66%的iowait 和 34%的CPU busy.</p>

<p>假设,对I/O系统进行了优化(比如增加了磁盘缓存),每次I/O操作只需要1ms,那么每次事务只需要11ms,那么程序每秒就可以执行90-91次事务了.这种情况下iowait大概在8%.因此更低的iowait时间直接影响了程序的执行能力(吞吐量).</p>

<h3 id="toc_2">Example 2:</h3>

<p>假设系统中有一个正在执行的程序,例如 &#39;dd&#39;程序,每次从磁盘读取4kb的数据.假设dd中的一个函数main()会调用read()方法来读取数据.main函数和read函数都是用户态的函数.read方法是libc.a提供的一个函数,这个函数会调用kread()系统调用,从而进入内核态.kread()会初始化设备并进行一次物理I/O,&#39;dd&#39;程序在此期间会睡眠(sleep)直到物理I/O完成.执行main,read,kread代码需要的时间很短 - 大概只需要50微秒,对于磁盘而言,完成I/O请求大概需要2-20ms,主要取决于磁盘的机械臂寻址的时间.因此,当时钟中断发生时,&#39;dd&#39;程序很可能在睡眠状态,I/O处在执行中的状态.因此,&#39;iowait&#39;计数器会增加.如果I/O在2ms完成,&#39;dd&#39;程序就继续执行下一次读操作.但是对比起来,50微秒要远远少于20ms,当时钟中断发生时,CPU更有可能还是处于idle状态,I/O任务仍然在进行中.因此,&#39;iowait&#39;还会增加.如果执行&#39; sar -P <cpunumber>&#39;来统计这个CPU的使用状态,iowait很可能处于97-98%.如果每次I/O需要20ms,那iowait可能会是99-100%.因此尽管I/O wait非常高,但是吞吐量依然比第一个例子中的情况要高10倍左右.</p>

<h3 id="toc_3">Example 3</h3>

<p>假设在同一个CPU上正在执行2个程序.其中一个&#39;dd&#39;负责从磁盘读取数据,另一个程序不会执行I/O操作,但是100%的时间都用来做计算工作.现在,假设I/O系统出现了故障,需要1s才能完成一次物理I/O操作.因此,当&#39;dd&#39;程序处于睡眠状态等待I/O结束时,另一个程序依然可以使用CPU.当时钟中断发生时,总会有一个程序处于用户态或内核态,因此 %idle和%iowait会是0.即便iowait是0,并不意味着就没有I/O问题,因为显然一次I/O执行超过了一秒是肯定有问题的.</p>

<h3 id="toc_4">Example 4</h3>

<p>假设在一个4核CPU的系统上有6个程序在执行.假设有4个程序,花费了70%的时间在等待物理I/O,还有30%时间真正使用了CPU.由于这四个程序需要进入内核态来执行kread系统调用,这就会花费部分比例的时间在内核中;假设有25%的时间是用户态,5%是内核态.</p>

<p>另外,我们假设剩下的两个程序消耗100%的时间全部用来计算,没有I/O请求,所以CPU永远都会100%忙碌.其他4个程序只需要30%的CPU资源,这俩程序就可以使用剩下的CPU资源了.</p>

<p>如果我们执行 &#39;sar -P ALL 1 10&#39;,通过每秒执行一次&#39;sar&#39;,一共10次,我们能够看到每次执行的结果如下:</p>

<pre><code class="language-text">cpu    %user    %sys   %wio    %idle
0        50       10     40       0
1        50       10     40       0
2        100      0       0       0 
3        100      0       0       0
-         75      5       20      0
</code></pre>

<p>注意一下,CPU使用的分配,75%为user,5%是sys,20%的iowait.如果通过&#39;vmstat&#39;或&#39;iostat&#39;等其他工具,看到的就是所有CPU的平均值.</p>

<p>现在,让我们把同样的负载(同样的6个程序,同样的执行情况)放到另一台有6核CPU(同样的CPU速度和同样的IO系统)的机器上执行.现在,各个程序都可以在独立的一个CPU上执行了,因此CPU的使用情况如下:</p>

<pre><code class="language-text">cpu    %user    %sys    %wio    %idle
0         25       5      70        0
1         25       5      70        0
2         25       5      70        0
3         25       5      70        0
4        100       0       0        0
5        100       0       0        0
-         50       3      47        0
</code></pre>

<p>现在,平均的CPU使用率为50% user,3% sys, 47% iowait.注意一下,同样的负载情况,在另一台机器会导致iowait的值提高了2倍多.</p>

<h3 id="toc_5">结论</h3>

<p>iowait的结果对于衡量I/O性能可能有用,也可能没什么用.但是至少告诉了我们系统能负担更多的计算任务,因为CPU处在iowait状态不代表CPU就不能执行其他进程了;因此,iowait只是另一种idle的状态而已.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryPath中文乱码问题,UTF8乱码问题解决]]></title>
    <link href="blog.v2cb.com/15923063084242.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063084242.html</id>
    <content type="html"><![CDATA[
<p>最近研究Spider,找到了PHP的QueryPath库.之前用Python的BeautifulSoup也挺方便,这个跟Python的那个库还是蛮像的.</p>

<p>但是用起来的时候就蛋疼了,发现UTF8的中文总是乱码.研究了好久,尝试了mb_convert_encoding各种姿势,还是不能解锁</p>

<p>最终在github的一个issue里发现了,这个issue有人提出来了.按着lz的参数配置,传给qp()方法:</p>

<pre><code class="language-text">$qp_options = array(
        &#39;convert_from_encoding&#39; =&gt; &#39;UTF-8&#39;,
        &#39;convert_to_encoding&#39; =&gt; &#39;UTF-8&#39;,
        &#39;strip_low_ascii&#39; =&gt; FALSE,
        );

$qp = htmlqp($html, null, $qp_options)-&gt;find(&quot;.text&quot;)-&gt;find(&quot;p&quot;)-&gt;text();
</code></pre>

<p>并且记得,如果是HTML的片段,没有完整的HTML,还是要自己给补全一下HTML才能正确识别.</p>

<pre><code class="language-text">$html = &#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&#39;;
$html .= &#39;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;&#39;;
$html .= $htmlString;
$html .= &#39;&lt;/body&gt;&lt;/html&gt;&#39;;
$qp = htmlqp($html, null, $qp_options)-&gt;find(&quot;.text&quot;)-&gt;find(&quot;p&quot;)-&gt;text();
</code></pre>

<p>中文问题就解决了.看样子是在新版中修复了这个bug,并不需要去搞mb_convert_encoding了.吐槽一下querypath的手册,写的还是有点shit.</p>

<p>ps: 如果是完整的HTML代码/网页,GBK编码也会有问题.这个是跟<meta http-equiv="Content-Type" content="text/html; charset=gbk" /> 有巨大关系的.需要把HTML的代码用mb_convert_encoding转换成UTF8,并把html中meta标签那个charset=gbk replace成charset=utf8,如此才能正确显示.编码问题真是坑爹啊.</p>

<p>github的issue地址:<a href="https://github.com/technosophos/querypath/issues/94">https://github.com/technosophos/querypath/issues/94</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WorkerMan的restart命令的一个Bug修复记录]]></title>
    <link href="blog.v2cb.com/15923063084445.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063084445.html</id>
    <content type="html"><![CDATA[
<p>最近一个项目更新之后总是出问题,守护进程总是自己会挂掉,日志显示重启失败,之前一直好好的.周末一个下午DEBUG,终于搞定了.记录一下.</p>

<pre><code class="language-text">前情提要:
    用PHP的WorkerMan写了一个Worker进程,监听Redis队列,另外的项目往队列里塞URL然后异步执行.很简单,一直运行稳定.但是以防万一,最近上线写了一个watcher,通过crontab每分钟监控这个队列往队列写入一个任务,如果执行超时,就调用WorkerMan的restart命令进行重启.
    除此之外还有一个Worker,监听数据库执行定时任务,原理类似.
    程序入口文件 StartWorker.php代码大致如下

    $task = new Worker();
    $task-&gt;onWorkerStart = function($task)
    {
        $dispatch = new dispatch();
        $dispatch-&gt;run();
    };
    $cronQueue = new Worker();
    $cronQueue-&gt;onWorkerStart = function($task)
    {
        $cronjob = new cron();
        $cronjob-&gt;run();
    };
    Worker::runAll();

    启动成功后,Workerman生成三个进程,一个master,两个Worker
</code></pre>

<p>通过Log判断,是watcher在对Workerman执行restart的时候出现了问题.Log中重复的都是</p>

<pre><code class="language-text">Workerman[./StartServer.php] restart
Workerman[./StartServer.php] is stoping ...
Workerman[./StartServer.php] stop fail
</code></pre>

<p>所以从WorkerMan执行restart看起吧.</p>

<p>watcher,调用restart命令:./StartServer.php restart -d </p>

<p>从WorkerMan的执行流程看起:</p>

<pre><code class="language-text">public static function runAll()
    {
        // 初始化环境变量
        self::init();
        // 解析命令
        self::parseCommand();
        // 尝试以守护进程模式运行
        self::daemonize();
        // 初始化所有worker实例，主要是监听端口
        self::initWorkers();
        //  初始化所有信号处理函数
        self::installSignal();
        // 保存主进程pid
        self::saveMasterPid();
        // 创建子进程（worker进程）并运行
        self::forkWorkers();
        // 展示启动界面
        self::displayUI();
        // 尝试重定向标准输入输出
        self::resetStd();
        // 监控所有子进程（worker进程）
        self::monitorWorkers();
    }
</code></pre>

<p>parseCommand这一步,解析了命令中的restart命令.伪代码</p>

<pre><code class="language-text">parseCmd (){
    switch
    case: restart
    case: stop
        $master_pid = @file_get_contents(self::$pidFile);
        $master_pid &amp;&amp; posix_kill($master_pid, SIGINT);//向正在运行的WorkerMan的Master发送SIGINT信号让其退出
        while(1) {  
            // 检查主进程是否存活
            $master_is_alive = $master_pid &amp;&amp; posix_kill($master_pid, 0);
            if($master_is_alive){
                //等待5s 超时则说明master进程没有退出,continue 继续while循环
            }
        }
        
</code></pre>

<p>所以restart命令就是通过向正在运行的Master进程发送SIGINT让原来的Master和Worker全部退出,然后自己启动接替原来的工作.log中一直stop失败,通过ps aux | grep WorkerMan可以发现,原来的Master还在运行,但是Worker已经全部退出了.<br/>
<img src="media/blog/workerman_grep1.png" alt=""/></p>

<p>继续研究,向Master进程发送SIGINT的时候执行了什么呢?</p>

<p>启动的时候,通过installSignal()定义了处理signal的方法</p>

<pre><code class="language-text">pcntl_signal(SIGINT,  array(&#39;\Workerman\Worker&#39;, &#39;signalHandler&#39;), false);
</code></pre>

<p>发现SIGINT信号对应的处理方法是self::stopAll();</p>

<p>StopAll的伪代码如下:</p>

<pre><code class="language-text">self::$_status = self::STATUS_SHUTDOWN;
if(self::$_masterPid === posix_getpid())
{
    //如果是master 则向Worker发送SIGINT信号
    $worker_pid_array = self::getAllWorkerPids();
    foreach($worker_pid_array as $worker_pid)
    {
        posix_kill($worker_pid, SIGINT);
    }
} else {
    //如果是Worker 则执行stop方法进行清理并退出
    foreach(self::$_workers as $worker)
    {
        $worker-&gt;stop();
    }
    exit(0);
}

</code></pre>

<p>这一步应该是ok的,因为ps aux|grep Worker ,child已经没有了,只剩下master了.<br/>
此处并没有Master退出的相关代码,但是可以看到,做了status的标记,所以一定在其他地方实现了对status的监控.<br/>
搜索STATUS_SHUTDOWN,发现在879行,monitorWorkers()函数里.开始分析这个函数:</p>

<pre><code class="language-text">while(1)
{
    //此处会suspand阻塞,直到有Worker退出,并返回退出的Worker的pid
    $status = 0;
    $pid = pcntl_wait($status, WUNTRACED);
    if($pid &gt; 0)
    {
        //pid&gt;0说明退出的是子进程 需要判断当前的status状态决定是否需要启动新的Worker来补充退出的Worker  ﻿
        foreach(self::$_pidMap as $worker_id =&gt; $worker_pid_array)
        {
            if(isset($worker_pid_array[$pid]))
            { 
                //log
                // 清除退出的Worker信息
                unset(self::$_pidMap[$worker_id][$pid]);
            }
        }
        // 如果不是关闭状态，则补充新的进程
        if(self::$_status !== self::STATUS_SHUTDOWN) self::forkWorkers();
    } else {
        // 如果是关闭状态，并且所有进程退出完毕，则主进程退出
        if(!self::getAllWorkerPids()) self::exitAndClearAll();
    }
}
</code></pre>

<p>这个函数是启动后执行的最后一个函数,是master进程执行的.这个函数通过while(1)循环来保证master一直运行,通过</p>

<pre><code class="language-text">    $pid = pcntl_wait($status, WUNTRACED);
</code></pre>

<p>来同步子进程的退出状态.pcntl_wait函数会一直阻塞直到有子进程退出,然后会返回子进程的PID.<br/>
master检测到有子进程退出后记录子进程退出的status到日志中,然后重点来了</p>

<pre><code class="language-text">    // 如果不是关闭状态，则补充新的进程
    if(self::$_status !== self::STATUS_SHUTDOWN)
</code></pre>

<p>也就是,在此检查self::$_status变量,之前在stopAll方法中,已经设置了这个变量为self::STATUS_SHUTDOWN<br/>
如果status不是SHUTDOWN状态,则在此新建worker进程来替补掉退出的Worker进程.此处不管,我们要看的是退出部分</p>

<pre><code class="language-text">    // 如果是关闭状态，并且所有进程退出完毕，则主进程退出
    if(!self::getAllWorkerPids())
    {
        self::exitAndClearAll();
    }
</code></pre>

<p>在此打印了一下,果然有返回值,所以此处的self::exitAndClearAll();并没有执行,master也就没有退出.为啥有child退出了但是没有清除自己的pid信息呢?继续研究一下</p>

<p>之前有写,在调用posix_kill($master_pid, 0);后会有一个5s的超时时间,如果在这个时间内master还没有被kill完成重启则显示失败.把这块注释掉,让它一直发送kill信号试试</p>

<p>此刻ps一下是这样的:<br/>
<img src="media/blog/workerman_grep2.png" alt=""/></p>

<p>我了个擦,child还都在.strace一下24776,在不断的发送kill<br/>
    kill(24773, SIG_0)                      = 0<br/>
而接收kill信号的24773当然是在不断的写入log,child not stopping.这不科学啊,明显死锁了<br/>
重来,把timeout改长一点,100s试试<br/>
这次是这样的:<br/>
<img src="media/blog/workerman_grep3.png" alt=""/><br/>
25010进程是手动执行restart的进程,strace后发现在不断发送kill信号给24934.<br/>
而24934则是上一次启动的master,需要被干掉的,strace -p 24934如下</p>

<pre><code class="language-text">open(&quot;/tmp/worker.txt&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3
fstat(3, {st_mode=S_IFREG|0666, st_size=16862, ...}) = 0
lseek(3, 0, SEEK_CUR)                   = 0
lseek(3, 0, SEEK_CUR)                   = 0
write(3, &quot;{\&quot;24936\&quot;:24936}\r\n&quot;, 17)   = 17
</code></pre>

<p>也就是master还是能不断获取到24936这个child,worker在退出的时候,没有把自己注册在self::\(_pidMap中的变量清除掉.<br/>
启动后,打印一下self::\)_pidMap 结果如下</p>

<pre><code class="language-text">{&quot;0000000006ee73ef00000000161a6a05&quot;:{&quot;25379&quot;:25379},&quot;0000000006ee73ed00000000161a6a05&quot;:{&quot;25380&quot;:25380}}
</code></pre>

<p>说明这个数组是没问题的.<br/>
搜索这个数组,在874行,stopAll里面有清除的方法,子进程在退出的时候,会完成这一步.</p>

<pre><code class="language-text">    // 清除子进程信息
    unset(self::$_pidMap[$worker_id][$pid]);
</code></pre>

<p>在此调试,发现问题出现在monitorWorkers的pcntl_wait()上.<br/>
然而在此打印pid,返回了三次 分别是<br/>
-1<br/>
-1<br/>
25683<br/>
说明有一个进程的pid没有返回,在master中monitorWorkers时,通过pcntl_wait监控子进程退出,然而返回了-1错误.所以这个子进程已经退了,master还以为它没退,就只好一直等着它退出,就卡死了.思考了半天,在monitorWorkers中,if的判断是通过self::getAllWorkerPids()函数来获取所有的Worker的pid的,这个函数很简单:</p>

<pre><code class="language-text">foreach(self::$_pidMap as $worker_pid_array)
{
    foreach($worker_pid_array as $worker_pid)
    {
        $pid_array[$worker_pid] = $worker_pid;
    }
}
</code></pre>

<p>基本上就是返回了self::$_pidMap中的值,然而master没有收到正确的Worker退出的pid,而是收到了-1,所以这个数组就一直不是空的.那么稍微改造一下,让这个方法只返回&quot;活着的Worker&quot;,可以通过posix_kill来实现:</p>

<pre><code class="language-text"> foreach($worker_pid_array as $worker_pid)
{
    if(posix_kill($worker_pid, 0)) $pid_array[$worker_pid] = $worker_pid;
}
</code></pre>

<p>如此一来,Master就不会在获取僵尸Worker了,能够顺利退出,问题解决了.</p>

<p>PS:至于为什么子进程退出了,pcntl_wait还是返回了-1,这一块还是没有很清楚.得继续试验一下了.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac安装mysql-python(with XAMPP)]]></title>
    <link href="blog.v2cb.com/15923063084788.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063084788.html</id>
    <content type="html"><![CDATA[
<p>继续研究flask框架,SQL部分准备用SQLAlchemy.调用的时候报错:</p>

<pre><code class="language-text">ImportError: No module named MySQLdb
</code></pre>

<p>搜了一下,需要安装mysql-python :<a href="http://stackoverflow.com/questions/25459386/mac-os-x-environmenterror-mysql-config-not-found">http://stackoverflow.com/questions/25459386/mac-os-x-environmenterror-mysql-config-not-found</a></p>

<pre><code class="language-text">sudo pip install mysql-python
</code></pre>

<p>安装的时候,报错 找不到mysql_config.想到之前装过XAMPP,里面是包含mysql的.</p>

<pre><code class="language-text">$ locate mysql_config
/Applications/XAMPP/xamppfiles/bin/mysql_config

</code></pre>

<p>果然有.加入到PATH里就能找到了</p>

<pre><code class="language-text">export PATH=$PATH:/Applications/XAMPP/xamppfiles/bin/
</code></pre>

<p>装好之后运行,还是报错:</p>

<pre><code class="language-text">Reason: unsafe use of relative rpath libmysqlclient.18.dylib in /Library/Python/2.7/site-packages/_mysql.so with restricted binary
</code></pre>

<p>搜了一下,跟新macos EICapitan的安全机制有关系:<a href="http://stackoverflow.com/questions/31343299/mysql-improperly-configured-reason-unsafe-use-of-relative-path">http://stackoverflow.com/questions/31343299/mysql-improperly-configured-reason-unsafe-use-of-relative-path</a></p>

<p>按着答案,执行</p>

<pre><code class="language-text">sudo install_name_tool -change libmysqlclient.18.dylib /Applications/XAMPP/xamppfiles/lib/libmysqlclient.18.dylib /Library/Python/2.7/site-packages/_mysql.so
</code></pre>

<p>终于执行成功了.</p>

<p>总结:stackoverflow真是个好东西.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018-08-01反思]]></title>
    <link href="blog.v2cb.com/15923063084891.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063084891.html</id>
    <content type="html"><![CDATA[
<p>上班路上,开始听&quot;东吴同学会&quot;这个有声节目了,之前觉得东吴相对论讲的一般,三年后的复出不知道怎么样.结果听了一下,发现对我的感触挺深,总结一下.</p>

<p>听的这期讲的是&quot;文字之道&quot;,讲写字的事儿.说现在互联网内容行业,能写好&quot;文章&quot;的人,要求不高,能把话讲明白事儿理顺了的人,比程序员还稀缺.为什么呢,因为现在移动互联网太过发达,人们每天接触的看到的生活的都是碎片化的,一个视频从一小时短到一分钟短到十五秒,人们已经很难在深入的线性化的思考一个事儿并进行表述了,所以互联网其实从根本上改变了我们的思维模式,让人退化了.</p>

<p>虽然这个问题已经是老生常谈了,但是我最近一段时间里做的反思,发现这也是我的一个问题之一. 碎片化带来的问题.除了思维逻辑上不够连贯以至于思考不够深入,还一个恶果就是视野的分散导致精力的不够聚焦,并且由此引发的一系列焦虑等等问题.所谓的视野,每天所看所思,其实很多东西不是我们主动去寻找的,现在的各种互联网产品都在拼命抓你的注意力,一个东西一不小心看到了 因为好奇就可能会点开.虽然明知道是标题党,还是想进去看看的冲动肯定每个人都会有,这是人性.由此我获取了很多不必要的信息,成都发大水了,台风要来了,北京出租车撞人了,乱七八糟的东西极大的分散了注意力,而精力 恰恰是最宝贵的财富之一.</p>

<p>除了时间,&quot;精力&quot; 其实是更重要的资产,我觉得&quot;精力&quot;的定义可以算做是&quot;有效时间&quot;,一天虽然在公司坐了十个小时,但是真正有效的时间,也就是&quot;精力&quot;,肯定要打折扣的.然后光有这个认识还不行,得学会去对抗人性,那就是&quot;不见为净&quot;.之前整天刷的论坛,本质上跟抖音头条是一路东西,虽然有用的信息不能说一点没有,但是相对投入来说产出还是不值得.最近已经逐步改掉了,每天起床和累了休息的一些固定时间刷一下,平时控制住自己.</p>

<p>除了控制信息源,还有一个学习的方式问题.面过很多人,包括我自己,所谓的&quot;在工作中学习&quot;,无外乎是遇到问题百度/谷歌一下解决方案,是一种比较急功近利的思路.一方面,谷歌出来的各种&quot;文章&quot;和Blog的作者水平可能就不咋地,而且互相之间也是抄来抄去,获取信息的效率与准确性是有问题的.而且这也是一种&quot;碎片化&quot;的学习,由此带来的知识体系不够系统的问题,对于工程师而言肯定是不健康的.这方面我觉得刘未鹏在暗时间里面说的自己的学习方法就靠谱一些,每个领域的书找几本基本上就都能覆盖到了,然后快速阅读做索引,在需要的时候能根据索引快速找到自己需要的东西,毕竟出书的作者水平一般还是要比博客作者的水平高一些,而且会更严谨.</p>

<p>工作这几年,一直很在意的是&quot;生产效率&quot;,却一直忽略了&quot;学习效率&quot;的总结反思,觉得现在学点东西的速度还是不够快,很多习惯还是上学时候的习惯.想想自己一直这么在意效率却忽略了这一块的效率,实在是不应该的,所以必须持续反思和修改自己的学习方法来提升效率,是为记.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP的多线程Curl,rolling Curl实现与坑]]></title>
    <link href="blog.v2cb.com/15923063085282.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063085282.html</id>
    <content type="html"><![CDATA[
<p>Tags:  PHP curl mutil_curl 多线程<br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>最近需要做群发推送,之前的推送只有单发的API,因为分IOS跟安卓平台,最简单的实现还是塞到队列去一个一个发,毕竟用户不多也就几万个.之前的请求队列没用多线程请求,每次一个.然而这个推送接口速度太挫,ios经常要2-3s才返回,几万个单线程请求得等死了.于是开始研究PHP的多线程Curl<br/>
  之前知道有mutil_curl可以实现,以为很简单.实际操作起来,坑还是相当多的.</p>

<p>php手册参考：</p>

<blockquote>
<p><a href="http://php.net/manual/zh/book.curl.php">http://php.net/manual/zh/book.curl.php</a></p>
</blockquote>

<p>curl_multi_init()相关：</p>

<blockquote>
<p><a href="http://php.net/manual/zh/function.curl-multi-init.php">http://php.net/manual/zh/function.curl-multi-init.php</a></p>
</blockquote>

<p>手册说的很简单，并附了一个演示脚本，如下。</p>

<pre><code class="language-text">&lt;?php
// 创建一对cURL资源
$ch1 = curl_init();
$ch2 = curl_init();
 
// 设置URL和相应的选项
curl_setopt($ch1, CURLOPT_URL, &quot;http://www.example.com/&quot;);
curl_setopt($ch1, CURLOPT_HEADER, 0);
curl_setopt($ch2, CURLOPT_URL, &quot;http://www.php.net/&quot;);
curl_setopt($ch2, CURLOPT_HEADER, 0);
 
// 创建批处理cURL句柄
$mh = curl_multi_init();
 
// 增加2个句柄
curl_multi_add_handle($mh,$ch1);
curl_multi_add_handle($mh,$ch2);
 
$running=null;
// 执行批处理句柄
do {
    usleep(10000);
    curl_multi_exec($mh,$running);
} while ($running &gt; 0);
 
// 关闭全部句柄
curl_multi_remove_handle($mh, $ch1);
curl_multi_remove_handle($mh, $ch2);
curl_multi_close($mh);
</code></pre>

<p>演示脚本说明了工作流程。</p>

<p>1、curl_multi_init，初始化多线程curl批处理会话。</p>

<p>2、curl_multi_add_handle，将具体执行任务的curl添加到multi_curl批处理会话。</p>

<p>3、curl_multi_exec，真正开始执行curl任务。</p>

<p>4、curl_multi_getcontent，获取执行结果。</p>

<p>5、curl_multi_remove_handle，将完成了的curl移出批处理会话。</p>

<p>6、curl_multi_close，关闭curl批处理会话。</p>

<p>mutil_curl相对于传统curl,最重要的还是理解几个概念.mutil_curl相当于一个请求线程池,这里的每一个请求都是一个单独的curl对象,跟传统的curl一样.curl_multi_add_handle方法就是往线程池里添加新的curl对象,但是并不执行.curl_multi_exec则会从线程池中拿一个curl去请求,这个时候是异步非阻塞的,所以很多请求也可以一下发出去,效率高多了.请求有返回了咋办呢,官方例子写的不好,其实有更好的方法.通过curl_multi_select方法,系统会阻塞直到有请求返回.这不就是回调通知么.而且curl_multi_select支持超时,所以非常好用.代码写出来如下:</p>

<pre><code class="language-text">&lt;?php
//bad example. 错误的例子
$start_time = microtime();
date_default_timezone_set(&#39;PRC&#39;);
 
$targets = array();//150个网址，自行添加目标
 
$total = count($targets);
echo &quot;共有{$total}个目标:\n&quot;;
 
$mh = curl_multi_init();
 
$opt = array ();
$opt[CURLOPT_HEADER] = false;
$opt[CURLOPT_CONNECTTIMEOUT] = 15;
$opt[CURLOPT_TIMEOUT] = 30;
$opt[CURLOPT_AUTOREFERER] = true;
$opt[CURLOPT_RETURNTRANSFER] = true;
$opt[CURLOPT_FOLLOWLOCATION] = true;
$opt[CURLOPT_MAXREDIRS] = 10;
 
foreach($targets as $target){
    $ch = curl_init($target);
    curl_setopt_array($ch, $opt);
    curl_multi_add_handle($mh, $ch);//要设置每个curl实例的属性
    unset($ch);
}
 
$index = 1;
do{
    do{
        curl_multi_exec($mh, $running);
        curl_multi_select($mh, 1.0);
    }while($running);
 
    while($info = curl_multi_info_read($mh)){
            $ch = $info[&#39;handle&#39;];
            $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
     
    if($info[&#39;result&#39;] == CURLE_OK){
                $content = curl_multi_getcontent($ch);
                $detail = getTitle($content);
            }else
                $detail =  &#39;cURL Error(&#39; . curl_error($ch) . &quot;).&quot;;
     
    echo &quot;[$index][&quot;, date(&#39;H:i:s&#39;), &quot;]{$url}:{$detail}\n&quot;;
            $index++;
    }
 
}while($running);
 
curl_multi_close($mh);
 
function getTitle($html){
    preg_match(&quot;/&lt;title&gt;(.*)&lt;\/title&gt;/isU&quot;, $html, $title);
    return empty($title[1]) ? &#39;未能获取标题&#39; : $title[1];
}
 
echo &quot;抓取完成!\n&quot;;
$end_time = microtime();
$start_time = explode(&quot; &quot;, $start_time);
$end_time = explode(&quot; &quot;,$end_time);
$execute_time = round(($end_time[0] - $start_time[0] + $end_time[1] - $start_time[1]) * 1000) / 1000;
$execute_time = sprintf(&quot;%s&quot;, $execute_time);
echo &quot;脚本运行时间：{$execute_time} 秒\n&quot;;
</code></pre>

<p>curl_multi_select()这个方法的返回值,手册上是这样写的:</p>

<blockquote>
<p>成功时返回描述符集合中描述符的数量。失败时，select失败时返回-1，否则返回超时(从底层的select系统调用).</p>
</blockquote>

<p>但是其实curl_multi_select可能会一直返回-1,所以这时候并不是真失败了,建议写的是继续执行curl_multi_exec.所以会写在一个while循环里.注意这些问题除了受代码编写的影响，还受php和libcurl版本的影响，总而言之升级版本吧。<br/>
  至于像 CURLM_CALL_MULTI_PERFORM 之类的预定义常量，php方面并没有详细解释，多半靠看名字猜，呵呵。</p>

<p>其实这些常量是由libcurl库定义的，参考地址：<br/>
  <a href="http://curl.haxx.se/libcurl/c/libcurl-errors.html">http://curl.haxx.se/libcurl/c/libcurl-errors.html</a><br/>
  CURLM_CALL_MULTI_PERFORM (-1)</p>

<p>This is not really an error. It means you should call curl_multi_perform again without doing select() or similar in between. Before version 7.20.0 this could be returned by curl_multi_perform, but in later versions this return code is never used.<br/>
  当返回值为-1时，并不意味着这是一个错误，只是说明select时没有并没有完成excute，描述给的建议是不要执行select等阻塞操作，立即exec。<br/>
但是在libcurl的7.20版本之后，不再使用这个返回值了，原因是这个循环libcurl自己做了，就不再需要我们手动循环了。<br/>
同时注意curl_multi_select，其实还有第二个参数timeout，根据语焉不详的手册，这货应该是自带阻塞，所以就不再需要手动sleep了。</p>

<p>整个脚本的执行时间就是30秒多一点，刚好是为每个curl设置的超时时间.想了一下,这样写是每次把所有请求都发出去,相当于有多少请求就开多少线程,那如果一次搞几万请求 系统还不挂了.而且其实php并不能很好的处理这150个线程，导致很多目标获取标题失败了。</p>

<p>这就需要自己实现一个线程池，来掌控任务进度。<br/>
  思路就是用curl_multi_remove_handle一次添加n个url到multi_curl中，这个n就是线程数，这n个的组合队列就是线程池。</p>

<p>每执行完毕一个任务，就将对应的curl移除队列并销毁，同时加入新的目标，直至150个对象依次执行完毕。这样做的好处是，能保证线程池中始终有n个任务在进行，不必等这n个任务执行完毕后再执行下n个任务。<br/>
  思路有了，所以我们的代码看来是这样的：</p>

<pre><code class="language-text">&lt;?php
$start_time = microtime();
date_default_timezone_set(&#39;PRC&#39;);
 
$targets = array();//150个网址，自行添加目标
 
$total = count($targets);
 
$mh_pool = array();
$threads = 10;
$total_time = 0;
echo &quot;共有{$total}个目标:\n&quot;;
echo &quot;线程数：{$threads}\n&quot;;
 
$mh = curl_multi_init();
 
$opt = array ();
$opt[CURLOPT_HEADER] = false;
$opt[CURLOPT_CONNECTTIMEOUT] = 15;
$opt[CURLOPT_TIMEOUT] = 30;
$opt[CURLOPT_AUTOREFERER] = true;
$opt[CURLOPT_RETURNTRANSFER] = true;
$opt[CURLOPT_FOLLOWLOCATION] = true;
$opt[CURLOPT_MAXREDIRS] = 10;
 
if($total &lt; $threads)
    $threads = $total;
 
for($i=0;$i&lt;$threads;$i++){
    $task = curl_init(array_pop($targets));
    curl_setopt_array($task, $opt);
    curl_multi_add_handle($mh, $task);//要设置每个curl实例的属性
    unset($task);
}
 
$index = 1;
 
do{
    do{
        curl_multi_exec($mh, $running);
        if(curl_multi_select($mh, 1.0) &gt; 0)
            break;
    }while($running);
 
    while($info = curl_multi_info_read($mh)){
        $ch = $info[&#39;handle&#39;];
        $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
        $total_time += curl_getinfo($ch, CURLINFO_TOTAL_TIME);
         
        if($info[&#39;result&#39;] == CURLE_OK){
            $content = curl_multi_getcontent($ch);
            $detail = getTitle($content);
        }else
            $detail =  &#39;cURL Error(&#39; . curl_error($ch) . &quot;).&quot;;
         
        echo &quot;[$index][&quot;, date(&#39;H:i:s&#39;), &quot;]{$url}:{$detail}\n&quot;;
        $index++;
         
        curl_multi_remove_handle($mh, $ch);
        curl_close($ch);
        unset($ch);
         
        if($targets){
            $new_task = curl_init(array_pop($targets));
            curl_setopt_array($new_task, $opt);
            curl_multi_add_handle($mh, $new_task);//要设置每个curl实例的属性
        }
    }
 
}while($running);
 
curl_multi_close($mh);
 
function getTitle($html){
    preg_match(&quot;/&lt;title&gt;(.*)&lt;\/title&gt;/isU&quot;, $html, $title);
    return empty($title[1]) ? &#39;未能获取标题&#39; : $title[1];
}
 
echo &quot;抓取完成!\n&quot;;
$end_time = microtime();
$start_time = explode(&quot; &quot;, $start_time);
$end_time = explode(&quot; &quot;, $end_time);
$execute_time = round(($end_time[0] - $start_time[0] + $end_time[1] - $start_time[1]) * 1000) / 1000;
$execute_time = sprintf(&quot;%s&quot;, $execute_time);
echo &quot;http请求时间：{$total_time} 秒\n&quot;;
echo &quot;脚本运行时间：{$execute_time} 秒\n&quot;;
</code></pre>

<p>为了细化处理多线程curl每个请求的执行结果，我在curl_multi_select的返回值大于0的时候也跳出了当前exec循环，并通过curl_multi_info_read来获取已经完成的任务信息。这里封装下就可以做个回调，精细化处理每个任务。</p>

<p>另一个地方就是注意curl_multi_info_read需要多次调用。这个函数每次调用返回已经完成的任务信息，直至没有已完成的任务。问题4产生的原因就是因为我当时用了if没用while，这是一个小坑，但坑了我相当长的时间。当时非常无奈的解决方式是监控了整个执行过程，在所有任务完成后清点队列，把遗漏的再取出来。。。</p>

<p>这样搞之后,发现几百个请求已经很ok了,公司网络不是很好,请求1000次百度大概要几十秒.而且同时开起的$threads进程数量也不是越多越好,根据网络和CPU核数自己测试估计能取得个平衡.把请求队列扩大,搞到5000次,发现问题来了.</p>

<p>5000次请求,基本只有1500-1800次能成功,这肯定是有问题了.然而跟超时时间并没有关系.在每个环节打了log发现,在任务结束的时候$targets并没有全部pop出去.也就是说,剩下的请求根本就没发.这特么,是有错误还是停止条件的问题?</p>

<p>通过log记录每个请求之后的\(running值,也就是停止条件,发现\)running确实是变成0了,所以会退出循环.这个$running是这样来的:</p>

<blockquote>
<p>curl_multi_exec(\(mh, \)running);</p>
</blockquote>

<p>手册写的是:</p>

<pre><code class="language-text">int curl_multi_exec ( resource $mh , int &amp;$still_running )
处理在栈中的每一个句柄。无论该句柄需要读取或写入数据都可调用此方法。

参数
mh              由 curl_multi_init() 返回的 cURL 多个句柄。
still_running   一个用来判断操作是否仍在执行的标识的引用。
</code></pre>

<p>这特么说了没说一样啊.谁知道是啥意思. 通过log不断的观察,发现这个值,表示的是 &quot;正在进行中的线程数量&quot;,也就是当前有多少请求正在执行.然后就发现,这个值并不是每次都会减少1...有时候会有多个请求一起返回了,所以会减少多个.但是每次往池子里添加的新请求都是1,这样肯定越来越少了,最后$running就变成0了,但是请求任务还没有完...<br/>
  最终写了一个class,凑合撸吧.这样基本没问题了.</p>

<pre><code class="language-text">&lt;?php 
/*
 * Multi curl in PHP 
 * @author  rainyluo 
 * @date    2016-04-15
 */
class MultiCurl {
    //urls needs to be fetched 
    public $targets = array();
    //parallel running curl threads 
    public $threads = 10;
    //curl options 
    public $curlOpt = array();
    //callback function 
    public $callback = null;
    //debug ,will show log using echo 
    public $debug = true;
    
    //multi curl handler
    private $mh = null;
    //curl running signal 
    private $runningSig = null;


    public function __construct() {
        $this-&gt;mh = curl_multi_init();
        $this-&gt;curlOpt             = array(
            CURLOPT_HEADER         =&gt; false,
            CURLOPT_CONNECTTIMEOUT =&gt; 10,
            CURLOPT_TIMEOUT        =&gt; 10,
            CURLOPT_AUTOREFERER    =&gt; true,
            CURLOPT_RETURNTRANSFER =&gt; true,
            CURLOPT_FOLLOWLOCATION =&gt; true,
            CURLOPT_MAXREDIRS      =&gt; 5,
        );
        $this-&gt;callback = function($html) {
            echo md5($html);
            echo &quot;fetched&quot;; 
            echo &quot;\r\n&quot;;
        };
    }

    public function setTargets($urls) {
        $this-&gt;targets = $urls;
        return $this;
    }
    public function setThreads($threads) {
        $this-&gt;threads = intval($threads);
        return $this;
    }
    public function setCallback($func) {
        $this-&gt;callback = $func;
        return $this;
    }
    /* 
     * start running 
     */
    public function run() {
        $this-&gt;initPool();
        $this-&gt;runCurl(); 
    }

    /*
     * run multi curl 
     */
    private function runCurl() {
        do{
            //start request thread and wait for return,if there&#39;s no return in 1s,continue add request thread 
            do{
                curl_multi_exec($this-&gt;mh, $this-&gt;runningSig);
                $this-&gt;log(&quot;exec results...running sig is&quot;.$this-&gt;runningSig);
                $return = curl_multi_select($this-&gt;mh, 1.0);
                if($return &gt; 0){
                    $this-&gt;log(&quot;there is a return...$return&quot;);
                    break;
                }
                unset($return);
            } while ($this-&gt;runningSig&gt;0);

            //if there is return,read it 
            while($returnInfo = curl_multi_info_read($this-&gt;mh)) {
                $handler = $returnInfo[&quot;handle&quot;];
                if($returnInfo[&quot;result&quot;] == CURLE_OK) {
                    $url = curl_getinfo($handler, CURLINFO_EFFECTIVE_URL);
                    $this-&gt;log($url.&quot;returns data&quot;);
                    $callback = $this-&gt;callback;
                    $callback(curl_multi_getcontent($handler));
                } else {
                    $url = curl_getinfo($handler, CURLINFO_EFFECTIVE_URL);
                    $this-&gt;log(&quot;$url fetch error.&quot;.curl_error($handler));
                }
                curl_multi_remove_handle($this-&gt;mh, $handler);
                curl_close($handler);
                unset($handler);
                //add new targets into curl thread 
                if($this-&gt;targets) {
                    $threadsIdel = $this-&gt;threads - $this-&gt;runningSig;
                    $this-&gt;log(&quot;idel threads:&quot;.$threadsIdel);
                    if($threadsIdel &lt; 0) continue;
                    for($i=0;$i&lt;$threadsIdel;$i++) {
                        $t = array_pop($this-&gt;targets);
                        if(!$t) continue;
                        $task = curl_init($t);
                        curl_setopt_array($task, $this-&gt;curlOpt);
                        curl_multi_add_handle($this-&gt;mh, $task);
                        $this-&gt;log(&quot;new task adds!&quot;.$task);
                        $this-&gt;runningSig += 1;
                        unset($task);
                    }

                } else {
                    $this-&gt;log(&quot;targets all finished&quot;);
                }
            }
        }while($this-&gt;runningSig);
    }

    /*
     * init multi curl pool
     */
    private function initPool() {
        if(count($this-&gt;targets) &lt; $this-&gt;threads) $this-&gt;threads = count($this-&gt;targets);
        //init curl handler pool ...
        for($i=1;$i&lt;=$this-&gt;threads;$i++) {
            $task = curl_init(array_pop($this-&gt;targets));
            curl_setopt_array($task, $this-&gt;curlOpt);
            curl_multi_add_handle($this-&gt;mh, $task);
            $this-&gt;log(&quot;init pool thread one&quot;);
            unset($task);
        }
        $this-&gt;log(&quot;init pool done&quot;);
    }

    private function log($log) {
        if(!$this-&gt;debug) return false;
        ob_start();
        echo &quot;---------- &quot;.date(&quot;Y-m-d H:i&quot;,time()).&quot;-------------&quot;;
        if(is_array($log)) {
            echo json_encode($log);
        } else {
            echo $log;
        }
        $m = memory_get_usage();
        echo &quot;memory:&quot;.intval($m/1024).&quot;kb\r\n&quot;;
        echo &quot;\r\n&quot;;
        flush();
        ob_end_flush();
        unset($log);
    }
    public function __destruct(){
        $this-&gt;log(&quot;curl ends.&quot;);
        curl_multi_close($this-&gt;mh);
    }
    

}
</code></pre>

<p>用法:</p>

<pre><code class="language-text">$mu = new MultiCurl();
$callback = function($html) {
    var_dump($html);
};
$mu-&gt;setTargets($urls)-&gt;setCallback($callback)-&gt;setThreads(5)-&gt;run();
</code></pre>

<p>PS:一个插曲<br/>
  代码写的差不多的时候发现,每次请求快到2k的时候就崩溃了,报segmentation fault.这不坑爹呢么,上GDB看Coredump,捣鼓半天发现应该是跟内存回收有关系,找了半天也没有相关的解决方案,迷迷糊糊的.想想还是老路子,打log吧.每一步的内存都打出来,发现内存占用越来越多啊,每次请求要十几k的往上涨,最后一百多M了就挂了.这有问题啊,肯定有啥没释放的地方.把不用的变量都unset掉,猛然发现少了curl_multi_remove_handle(\(this-&gt;mh, \)handler);跟curl_close($handler) 这不坑爹呢么...链接忘了close,肯定不是释放了啊.终归还是对curl_mutil的内部不是很熟悉.估计里面的每个curl对象都是独立的,只有close之后才会被回收释放吧.改好之后,10个threads一起跑,基本上内存占用十几m不到,5k的请求也一会搞定了.妈蛋,充实的一天 自己给自己挖坑啊.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用PHP-CLI在SHELL中输出颜色]]></title>
    <link href="blog.v2cb.com/15923063085495.html"/>
    <updated>2020-06-16T19:18:28+08:00</updated>
    <id>blog.v2cb.com/15923063085495.html</id>
    <content type="html"><![CDATA[
<p>Tags:  PHP CLI <br/>
Toc:no<br/>
Status: public<br/>
Position: 1</p>

<p>刚才找PHP的手册,发现一个评论挺有意思.在PHP的CLI模式,也就是SHELL中,输出颜色.<br/>
写简单的脚本,Log什么的时候,有个颜色 ,看起来舒服多了.一直黑白的看的脑袋晕乎乎的.</p>

<pre><code class="language-text">&lt;? 
$_colors = array( 
        &#39;LIGHT_RED&#39;      =&gt; &quot;[1;31m&quot;, 
        &#39;LIGHT_GREEN&#39;     =&gt; &quot;[1;32m&quot;, 
        &#39;YELLOW&#39;     =&gt; &quot;[1;33m&quot;, 
        &#39;LIGHT_BLUE&#39;     =&gt; &quot;[1;34m&quot;, 
        &#39;MAGENTA&#39;     =&gt; &quot;[1;35m&quot;, 
        &#39;LIGHT_CYAN&#39;     =&gt; &quot;[1;36m&quot;, 
        &#39;WHITE&#39;     =&gt; &quot;[1;37m&quot;, 
        &#39;NORMAL&#39;     =&gt; &quot;[0m&quot;, 
        &#39;BLACK&#39;     =&gt; &quot;[0;30m&quot;, 
        &#39;RED&#39;         =&gt; &quot;[0;31m&quot;, 
        &#39;GREEN&#39;     =&gt; &quot;[0;32m&quot;, 
        &#39;BROWN&#39;     =&gt; &quot;[0;33m&quot;, 
        &#39;BLUE&#39;         =&gt; &quot;[0;34m&quot;, 
        &#39;CYAN&#39;         =&gt; &quot;[0;36m&quot;, 
        &#39;BOLD&#39;         =&gt; &quot;[1m&quot;, 
        &#39;UNDERSCORE&#39;     =&gt; &quot;[4m&quot;, 
        &#39;REVERSE&#39;     =&gt; &quot;[7m&quot;, 

); 

function termcolored($text, $color=&quot;NORMAL&quot;, $back=1){ 
    global $_colors; 
    $out = $_colors[&quot;$color&quot;]; 
    if($out == &quot;&quot;){ $out = &quot;[0m&quot;; } 
    if($back){ 
        return chr(27).&quot;$out$text&quot;.chr(27).chr(27).&quot;[0m&quot;.chr(27); 
    }else{ 
        echo chr(27).&quot;$out$text&quot;.chr(27).chr(27).&quot;[0m&quot;.chr(27); 
    }//fi 
}// end function 

foreach ($_colors as $key=&gt;$v) {
    echo termcolored(&quot;colors&quot;, $key);
    echo &quot;\r\n&quot;;
}
?&gt;
</code></pre>

]]></content>
  </entry>
  
</feed>
